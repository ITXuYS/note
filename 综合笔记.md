# 一.前置技术

## 1、配置文件

### 1.1、配置文件优先级

#### 1.1.1、3种类型配置文件优先级

三种类型,优先级从上到下

application.properties

application.yml

application.yaml

配置冲突的情况下使用优先级高的，不冲突的情况下都会被使用

#### 1.1.2、四级配置文件

| 级别 |         位置         |     使用人员     |
| :--: | :------------------: | :--------------: |
| 最高 |  工程路径config目录  | 运维经理整体调控 |
| 次高 |       工程路径       | 运维人员涉密调控 |
| 次低 | 项目类路径config目录 | 项目经理整体调控 |
| 最低 |      项目类路径      |     开发人员     |

位置说明

|         位置         |      举例路径C:\project\demo1      |
| :------------------: | :--------------------------------: |
|  工程路径config目录  | C:\project\config\application.yaml |
|       工程路径       |    C:\project\application.yaml     |
| 项目类路径config目录 | classpath:config\application.yaml  |
|      项目类路径      |     classpath:application.yaml     |



### 1.2、yaml

#### 1.2.1、简介

YAML 是 "YAML Ain't Markup Language"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。 



非常适合用来做以数据为中心的配置文件



#### 1.2.2、基本语法

- key: value；kv之间有空格
- 大小写敏感
- 使用缩进表示层级关系
- 缩进不允许使用tab，只允许空格
- 缩进的空格数不重要，只要相同层级的元素左对齐即可
- '#'表示注释
- 字符串无需加引号，如果要加，''与""表示字符串内容 会被 转义/不转义

#### 1.2.3、数据类型

- 字面量：单个的、不可再分的值。date、boolean、string、number、null

```yaml
k: v
```

* 对象：键值对的集合。map、hash、set、object

```yaml
行内写法：  k: {k1:v1,k2:v2,k3:v3}
#或
k: 
  k1: v1
  k2: v2
  k3: v3
```

- 数组：一组按次序排列的值。array、list、queue

```yaml
行内写法：  k: [v1,v2,v3]
#或者
k:
 - v1
 - v2
 - v3
```

#### 1.2.4、示例

```java
@Data
public class Person {
	
	private String userName;
	private Boolean boss;
	private Date birth;
	private Integer age;
	private Pet pet;
    private List<Pet> pets;
	private String[] interests;
	private List<String> animal;
	private Map<String, Object> score;
	private Set<Double> salarys;
	private Map<String, List<Pet>> allPets;
}

@Data
public class Pet {
	private String name;
	private Double weight;
}
```

```yaml
# yaml表示以上对象
person:
  userName: zhangsan
  boss: false
  birth: 2019/12/12 20:12:33
  age: 18
  pet: 
    name: tomcat
    weight: 23.4
  pets:
    -name: cat
     weight: 5
     -name: dog
     weight: 10
  interests: [篮球,游泳]
  animal: 
    - jerry
    - mario
  score:
    english: 
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: {first: 128,second: 136}
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - {name: tom}
      - {name: jerry,weight: 47}
    health: [{name: mario,weight: 47}]
    
#引用
pathA: 
 pathAa: C:
 pathAb: D:
pathB: \user
pathC: ${pathA.pathAa}\temp #C:/temp 
pathD: "${pathA.pathAa}\temp" #C: emp  加了双引号变转义字符 \t就是空格

user:
 name: ruyan
 age: 18
```

```java
@Value("${person.username}")
private String username;
@Value("${person.boss}")
private boolean boss;
@Value("${person.birth}")
private Date birth;
@Value("${person.age}")
private int age;
@Value("${person.pet.name}")
private String petName;
@Value("${person.pet.weight}")
private Double weight;
@Value("${person.pets[0].name}")
private String petsName;
@Value("${person.interests[0]}")
private String interests1;
@Value("${person.interests[1]}")
private String interests2;


//读取全部属性
Autowried 
private Enviroment env;
env.getProperty("person.username");
//-----------------------

//读取部分数据
@Data
//@Component
@ConfigurationProperties(prefix = "user")
public User user(){
    private String name;
    private int age;
}
//调用
//@Autoweied
private User user;

```



#### 1.2.5、yaml文件设置联想

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>


 <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-configuration-processor</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

### 1.3、多环境开发(yml)

#### 方式一:单个yml文件

```yml
#激活dev环境配置
spring:
  profiles.active: dev
 
 ----
# 开发环境配置
spring:
  profiles: dev
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/dev?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
server:
  port: 8080
 
---- 
 
# 测试环境配置
spring:
  profiles: test
  datasource:
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
    username: root
    password: test
    driver-class-name: com.mysql.jdbc.Driver
server:
  port: 88
 
 ----
# 生产环境配置
spring:
  profiles: prod
  datasource:
    url: jdbc:mysql://localhost:3306/prod?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC
    username: root
    password: prod
    driver-class-name: com.mysql.jdbc.Driver
 server:
  port: 99
```

#### 方式二:多个yml文件

步骤一、创建多个配置文件

```javascript
application.yml      #主配置文件
application-dev.yml  #开发环境的配置
application-prod.yml #生产环境的配置
application-test.yml #测试环境的配置
```

步骤二、applicaiton.yml中指定配置
在application.yml中选择需要使用的配置文件（当选择的文件和application.yml文件存在相同的配置时，application.yml中的配置会被覆盖掉）

文件可选择多个，多环境使用逗号分隔

当多个文件时， 文件中如果有相同配置时，会以最右侧的文件为主。

##### active引入多个文件

```yml
spring:
 profiles:
   active: dev,prod #需要使用的配置文件的后缀
```

配置默认的profile为dev，其他环境可以通过指定启动参数来使用不同的profile，比如：
 测试环境：java -jar 项目.jar --spring.profiles.active=test
 生产环境：java -jar 项目.jar --spring.profiles.active=prod

##### include引入多个文件(了解)

```yml
spring:
  profiles:
    active: dev
    include: dev,prod
server:
  port: 80
```

##### group 分组(最方便)

* 在springboot2.4版本开始使用group 代替include属性，降低了书写量

<img src="E:\课程资料\springboot\黑马springboot\图片\多环境group分组.png" style="zoom:150%;" />



```yml
spring:
  profiles:
    active: dev
    group:
      "dev": dev,devMVC,devRedis
      "prod": prod,prodMVC,prodRedis

```



#### 方式三：在pom.xml中指定环境配置

步骤一、创建多个配置文件

```javascript
application.yml      #主配置文件
application-dev.yml  #开发环境的配置
application-prod.yml #生产环境的配置
application-test.yml #测试环境的配置
```

步骤二、在application.yml中添加多环境配置属性
\#多环境配置

 ```yml
 spring:
  profiles:
    active: @profiles.active@
 ```



步骤三、在pom.xml中指定使用的配置

```xml
 <profiles>
        <profile>
            <id>dev</id>
            <activation>
                <!--  默认激活-->
                <activeByDefault>true</activeByDefault>
            </activation>
            <properties>
                <profiles.active>dev</profiles.active>
            </properties>
        </profile>
 
        <profile>
            <id>prod</id>
            <properties>
                <profiles.active>prod</profiles.active>
            </properties>
        </profile>
 
        <profile>
            <id>test</id>
            <properties>
                <profiles.active>test</profiles.active>
            </properties>
        </profile>
 </profiles>
```

<activeByDefault>true</activeByDefault>配置为true则激活对应profile的配置

或如图所示，在maven->profiles下勾选动态激活需要使用的配置

![](E:\课程资料\springboot\黑马springboot\图片\多环境开发pom配置.png)

避坑：不能识别符号@
在步骤二中配置的@profiles.active@，启动会报异常，不能识别@符号。解决方法：
在pom.xml中设置filtering为true



## 2、mybatis

### 2.1、快速入门

2.1.1、坐标

```xml
<dependencies>
  <!-- mybatis依赖 mybatis已经集成了JDBC，不需要再导入-->
  <<dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.3.0</version>
 </dependency>

  <!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! -->
  <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.2.1</version>
</dependency>

  <!--junit5测试-->
  <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>5.3.1</version>
  </dependency>
</dependencies>
```

### 2.2、基本使用

#### 2.2.1、配置

注解扫描：在Spring Boot的主应用类上添加@MapperScan注解，用于扫描和注册Mapper接口

yaml

```yaml
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost/xxdb
      username: root
      password: root

mybatis:
  mapper-locations: classpath:mapper/*.xml 
  #全类名，这样在xml中直接写类名就可以了
  type-aliases-package: com.sky.entity
  configuration:
    map-underscore-to-camel-case: true  #驼峰命名
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
    #auto-mapping-behavior: full 
```

xml 了解即可

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

    <settings>
        <!-- 开启驼峰式映射-->
        <setting name="mapUnderscoreToCamelCase" value="true"/>
        <!-- 开启logback日志输出-->
        <setting name="logImpl" value="SLF4J"/>
    </settings>

    <typeAliases>
        <!-- 给实体类起别名 -->
        <package name="com.atguigu.pojo"/>
    </typeAliases>

    <!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 -->
    <environments default="development">
        <!-- environment表示配置Mybatis的一个具体的环境 -->
        <environment id="development">
            <!-- Mybatis的内置的事务管理器 -->
            <transactionManager type="JDBC"/>
            <!-- 配置数据源 -->
            <dataSource type="POOLED">
                <!-- 建立数据库连接的具体信息 -->
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mybatis-example"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>

    <mappers>
        <!-- Mapper注册：指定Mybatis映射文件的具体位置 -->
        <!-- mapper标签：配置一个具体的Mapper映射文件 -->
        <!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 -->
        <!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 -->
        <mapper resource="mappers/UserMapper.xml"/>
    </mappers>

</configuration>
```



#### 2.2.2、向sql语句传参

##### 2.2.2.1 #{}

Mybatis会将SQL语句中的#{}转换为问号占位符

![](E:\课程资料\springboot\黑马springboot\图片\占位符1.png)

##### 2.2.2.2${}

${}形式传参，底层Mybatis做的是字符串拼接操作

![](E:\课程资料\springboot\黑马springboot\图片\占位符2.png)

通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用

结论：实际开发中，能用#{}实现的，肯定不用${}。

特殊情况： 动态的不是值，是列名或者关键字，需要使用${}拼接

```java
//注解方式传入参数！！
@Select("select * from user where ${column} = #{value}")
User findByColumn(@Param("column") String column, 
                                @Param("value") String value);
```

#### 2.2.3、数据输入

2.2.3.1、Map类型参数

```java
int updateEmployeeByMap(Map<String, Object> paramMap);

public void testUpdateEmpNameByMap() {
  EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);
  Map<String, Object> paramMap = new HashMap<>();
  paramMap.put("empSalaryKey", 999.99);
  paramMap.put("empIdKey", 5);
  int result = mapper.updateEmployeeByMap(paramMap);
  log.info("result = " + result);
}
```

```xml
<update id="updateEmployeeByMap">

  update t_emp set emp_salary=#{empSalaryKey} where emp_id=#{empIdKey}

</update>
```

#### 2.2.4、数据输出

##### 2.2.4.1返回主键

1 返回自增长类型主键

* Mapper接口中的抽象方法

```java
int insertEmployee(Employee employee);
```

* SQL语句

```xml
<!-- int insertEmployee(Employee employee); -->
<!-- useGeneratedKeys属性字面意思就是“使用生成的主键” -->
<!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 -->
<insert id="insertEmployee" useGeneratedKeys="true" keyProperty="empId">
  insert into t_emp(emp_name,emp_salary)
  values(#{empName},#{empSalary})
</insert>
```

注意

Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。

2 返回非自增长类型主键

而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！

使用 `selectKey` 帮助插入UUID作为字符串类型主键示例：

```xml
<insert id="insertUser" parameterType="User">
    <selectKey keyProperty="id" resultType="java.lang.String"
        order="BEFORE">
        SELECT UUID() as id
    </selectKey>
    INSERT INTO user (id, username, password) 
    VALUES (
        #{id},
        #{username},
        #{password}
    )
</insert>

```

在上例中，我们定义了一个 `insertUser` 的插入语句来将 `User` 对象插入到 `user` 表中。我们使用 `selectKey` 来查询 UUID 并设置到 `id` 字段中。

通过 `keyProperty` 属性来指定查询到的 UUID 赋值给对象中的 `id` 属性，而 `resultType` 属性指定了 UUID 的类型为 `java.lang.String`。

需要注意的是，我们将 `selectKey` 放在了插入语句的前面，这是因为 MySQL 在 `insert` 语句中只支持一个 `select` 子句，而 `selectKey` 中查询 UUID 的语句就是一个 `select` 子句，因此我们需要将其放在前面。

最后，在将 `User` 对象插入到 `user` 表中时，我们直接使用对象中的 `id` 属性来插入主键值。

使用这种方式，我们可以方便地插入 UUID 作为字符串类型主键。当然，还有其他插入方式可以使用，如使用Java代码生成UUID并在类中显式设置值等。需要根据具体应用场景和需求选择合适的插入方式。

##### 2.2.4.2实体类

建议开启驼峰命名，此处方法了解即可

使用resultMap

```xml
<!-- 专门声明一个resultMap设定column到property之间的对应关系 -->
<resultMap id="selectEmployeeByRMResultMap" type="com.atguigu.mybatis.entity.Employee">

  <!-- 使用id标签设置主键列和主键属性之间的对应关系 -->
  <!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 -->
  <id column="emp_id" property="empId"/>

  <!-- 使用result标签设置普通字段和Java实体类属性之间的关系 -->
  <result column="emp_name" property="empName"/>

  <result column="emp_salary" property="empSalary"/>

</resultMap>

<!-- Employee selectEmployeeByRM(Integer empId); -->
<select id="selectEmployeeByRM" resultMap="selectEmployeeByRMResultMap">

  select emp_id,emp_name,emp_salary from t_emp where emp_id=#{empId}

</select>
```

#### 2.2.5 mapperXML标签总结

##### 2.2.5.1**select标签：**

  MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单：

```XML
<select id="selectPerson" 
resultType="hashmap" resultMap="自定义结构"> SELECT * FROM PERSON WHERE ID = #{id} </select>
```

  这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。

  注意参数符号：#{id}  ${key}

  MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：

```Java
// 近似的 JDBC 代码，非 MyBatis 代码...
String selectPerson = "SELECT * FROM PERSON WHERE ID=?";
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);
```

  **select** 元素允许你配置很多属性来配置每条语句的行为细节：

| 属性            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| `id`            | 在命名空间中唯一的标识符，可以被用来引用这条语句。           |
| `resultType`    | 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 |
| `resultMap`     | 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 |
| `timeout`       | 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 |
| `statementType` | 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 |

statementType:指定 SQL 语句的执行方式

* STATEMENT:表示直接执行 SQL 语句，每次执行都会发送到数据库执行。这种方式适用于一些特殊的需求，例如需要执行存储过程或者动态 SQL
* PREPARED :`MyBatis 将直接执行 SQL 语句，并返回结果集。这种方式PARED`：表示预编译 SQL 语句，SQL 语句在第一次执行时会被数据库编译，然后缓存起来，之后的执行可以直接使用缓存的编译结果，提高了执行效率
* CALLABLE:表示调用存储过程或函数。这种方式适用于执行数据库存储过程或函数的情况。

##### 2.2.5.2**insert, update 和 delete标签：**

  数据变更语句 insert，update 和 delete 的实现非常接近：

```XML
<insert
  id="insertAuthor"
  statementType="PREPARED"
  keyProperty=""
  keyColumn=""
  useGeneratedKeys=""
  timeout="20">

<update
  id="updateAuthor"
  statementType="PREPARED"
  timeout="20">

<delete
  id="deleteAuthor"
  statementType="PREPARED"
  timeout="20">
```

| 属性               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `id`               | 在命名空间中唯一的标识符，可以被用来引用这条语句。           |
| `timeout`          | 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 |
| `statementType`    | 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 |
| `useGeneratedKeys` | （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 |
| `keyProperty`      | （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（`unset`）。如果生成列不止一个，可以用逗号分隔多个属性名称。 |
| `keyColumn`        | （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 |

### 2.3MyBatis多表映射

1. **实体类设计方案**

    多表关系回顾：（双向查看）

    - 一对一

        夫妻关系，人和身份证号
    - 一对多| 多对一

        用户和用户的订单，锁和钥匙
    - 多对多

        老师和学生，部门和员工

    实体类设计关系(查询)：（单向查看）

    - 对一 ： 夫妻一方对应另一方，订单对应用户都是对一关系

        实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！

        例如：

```Java
public class Customer {

  private Integer customerId;
  private String customerName;

}

public class Order {

  private Integer orderId;
  private String orderName;
  private Customer customer;// 体现的是对一的关系

}  

```
    - 对多: 用户对应的订单，讲师对应的学生或者学生对应的讲师都是对多关系：
    
        实体类设计：对多关系下，类中只要包含对方类型集合属性即可！

```Java
public class Customer {

  private Integer customerId;
  private String customerName;
  private List<Order> orderList;// 体现的是对多的关系
}

public class Order {

  private Integer orderId;
  private String orderName;
  private Customer customer;// 体现的是对一的关系
  
}

//查询客户和客户对应的订单集合  不要管!
```

    多表结果实体类设计小技巧：
    
      对一，属性中包含对方对象
    
      对多，属性中包含对方对象集合
    
      只有真实发生多表查询时，才需要设计和修改实体类，否则不提前设计和修改实体类！
    
      无论多少张表联查，实体类设计都是两两考虑!
    
      在查询映射的时候，只需要关注本次查询相关的属性！例如：查询订单和对应的客户，就不要关注客户中的订单集合！

#### 2.3.1对一映射

1. 需求说明

    根据ID查询订单，以及订单关联的用户的信息！
2. OrderMapper接口

```Java
public interface OrderMapper {
  Order selectOrderWithCustomer(Integer orderId);
}
```
3. OrderMapper.xml配置文件

```XML
一个对象中包含另外一个对象
<!-- 创建resultMap实现“对一”关联关系映射 -->
<!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” -->
<!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 -->
<resultMap id="selectOrderWithCustomerResultMap" type="order">

  <!-- 先设置Order自身属性和字段的对应关系 -->
  <id column="order_id" property="orderId"/>

  <result column="order_name" property="orderName"/>

  <!-- 使用association标签配置“对一”关联关系 -->
  <!-- property属性：在Order类中对一的一端进行引用时使用的属性名 -->
  <!-- javaType属性：一的一端类的全类名 -->
  <association property="customer" javaType="customer">

    <!-- 配置Customer类的属性和字段名之间的对应关系 -->
    <id column="customer_id" property="customerId"/>
    <result column="customer_name" property="customerName"/>

  </association>

</resultMap>

<!-- Order selectOrderWithCustomer(Integer orderId); -->
<select id="selectOrderWithCustomer" resultMap="selectOrderWithCustomerResultMap">

  SELECT order_id,order_name,c.customer_id,customer_name
  FROM t_order o
  LEFT JOIN t_customer c
  ON o.customer_id=c.customer_id
  WHERE o.order_id=#{orderId}

</select>
```

![](E:\课程资料\springboot\黑马springboot\图片\mybatis映射图1.png)

4. Mybatis全局注册Mapper文件

```XML
<!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 -->
<mappers>

  <!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 -->
  <mapper resource="mappers/OrderMapper.xml"/>

</mappers>
```

#### 2.3.2对多映射

1. 需求说明

    查询客户和客户关联的订单信息！
2. CustomerMapper接口

```Java
public interface CustomerMapper {

  Customer selectCustomerWithOrderList(Integer customerId);

}
```
3. CustomerMapper.xml文件

```Java
一个对象中包含另外一个对象的集合
<!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 -->
<resultMap id="selectCustomerWithOrderListResultMap" type="customer">

  <!-- 映射Customer本身的属性 -->
  <id column="customer_id" property="customerId"/>

  <result column="customer_name" property="customerName"/>

  <!-- collection标签：映射“对多”的关联关系 -->
  <!-- property属性：在Customer类中，关联“多”的一端的属性名 -->
  <!-- ofType属性：集合属性中元素的类型 -->
  <collection property="orderList" ofType="order">

    <!-- 映射Order的属性 -->
    <id column="order_id" property="orderId"/>

    <result column="order_name" property="orderName"/>

  </collection>

</resultMap>

<!-- Customer selectCustomerWithOrderList(Integer customerId); -->
<select id="selectCustomerWithOrderList" resultMap="selectCustomerWithOrderListResultMap">
  SELECT c.customer_id,c.customer_name,o.order_id,o.order_name
  FROM t_customer c
  LEFT JOIN t_order o
  ON c.customer_id=o.customer_id
  WHERE c.customer_id=#{customerId}
</select>
```

![](E:\课程资料\springboot\黑马springboot\图片\mybatis对多映射.png)

4. Mybatis全局注册Mapper文件

```XML
<!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 -->
<mappers>
  <!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 -->
  <mapper resource="mappers/OrderMapper.xml"/>
  <mapper resource="mappers/CustomerMapper.xml"/>
</mappers>
```
5.关键词

在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType”

#### 2.3.3多表映射总结

##### 2.3.3.1多表映射优化

| setting属性         | 属性含义                                                     | 可选值              | 默认值  |
| ------------------- | ------------------------------------------------------------ | ------------------- | ------- |
| autoMappingBehavior | 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 | NONE, PARTIAL, FULL | PARTIAL |


我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名=属性名，或者开启驼峰映射也可以自定映射）的result标签！

修改mybati-sconfig.xml:

```XML
<!--开启resultMap自动映射 -->
<setting name="autoMappingBehavior" value="FULL"/>
```

修改teacherMapper.xml

```XML
<resultMap id="teacherMap" type="teacher">
    <id property="tId" column="t_id" />
    <!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!-->
<!--        <result property="tName" column="t_name" />-->
    <collection property="students" ofType="student" >
        <id property="sId" column="s_id" />
<!--            <result property="sName" column="s_name" />-->
    </collection>
</resultMap>
```

##### 2.3.3.2关键字总结

| 关联关系 | 配置项关键词                              | 所在配置文件和具体位置            |
| -------- | ----------------------------------------- | --------------------------------- |
| 对一     | association标签/javaType属性/property属性 | Mapper配置文件中的resultMap标签内 |
| 对多     | collection标签/ofType属性/property属性    | Mapper配置文件中的resultMap标签内 |

### 2.4MyBatis动态语句

#### 2.4.1 if和where标签

```xml
<!-- List<Employee> selectEmployeeByCondition(Employee employee); -->
<select id="selectEmployeeByCondition" resultType="employee">
    select emp_id,emp_name,emp_salary from t_emp
    <!-- where标签会自动去掉“标签体内前面多余的and/or” -->
    <where>
        <!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true -->
        <!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 -->
        <if test="empName != null">
            <!-- 在if标签内部，需要访问接口的参数时还是正常写#{} -->
            or emp_name=#{empName}
        </if>
        <if test="empSalary &gt; 2000">
            or emp_salary>#{empSalary}
        </if>
        <!--
         第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary>?
         第二种情况：部分条件满足 WHERE emp_salary>?
         第三种情况：所有条件都不满足 没有where子句
         -->
    </where>
</select>
```



#### 2.4.2 set标签

```xml
<!-- void updateEmployeeDynamic(Employee employee) -->
<update id="updateEmployeeDynamic">
    update t_emp
    <!-- set emp_name=#{empName},emp_salary=#{empSalary} -->
    <!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 -->
    <set>
        <if test="empName != null">
            emp_name=#{empName},
        </if>
        <if test="empSalary &lt; 3000">
            emp_salary=#{empSalary},
        </if>
    </set>
    where emp_id=#{empId}
    <!--
         第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?
         第二种情况：部分条件满足 SET emp_salary=?
         第三种情况：所有条件都不满足 update t_emp where emp_id=?
            没有set子句的update语句会导致SQL语法错误
     -->
</update>
```



#### 2.4.3 trim标签【了解】

使用trim标签控制条件部分两端是否包含某些字符

- prefix属性：指定要动态添加的前缀
- suffix属性：指定要动态添加的后缀
- prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值
- suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值

```xml
<!-- List<Employee> selectEmployeeByConditionByTrim(Employee employee) -->
<select id="selectEmployeeByConditionByTrim" resultType="com.atguigu.mybatis.entity.Employee">
    select emp_id,emp_name,emp_age,emp_salary,emp_gender
    from t_emp
    
    <!-- prefix属性指定要动态添加的前缀 -->
    <!-- suffix属性指定要动态添加的后缀 -->
    <!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 -->
    <!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 -->
    <!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 -->
    <trim prefix="where" suffixOverrides="and|or">
        <if test="empName != null">
            emp_name=#{empName} and
        </if>
        <if test="empSalary &gt; 3000">
            emp_salary>#{empSalary} and
        </if>
        <if test="empAge &lt;= 20">
            emp_age=#{empAge} or
        </if>
        <if test="empGender=='male'">
            emp_gender=#{empGender}
        </if>
    </trim>
</select>
```



#### 2.4.4 choose/when/otherwise标签

在多个分支条件中，仅执行一个。

- 从上到下依次执行条件判断
- 遇到的第一个满足条件的分支会被采纳
- 被采纳分支后面的分支都将不被考虑
- 如果所有的when分支都不满足，那么就执行otherwise分支

```xml
<!-- List<Employee> selectEmployeeByConditionByChoose(Employee employee) -->
<select id="selectEmployeeByConditionByChoose" resultType="com.atguigu.mybatis.entity.Employee">
    select emp_id,emp_name,emp_salary from t_emp
    where
    <choose>
        <when test="empName != null">emp_name=#{empName}</when>
        <when test="empSalary &lt; 3000">emp_salary &lt; 3000</when>
        <otherwise>1=1</otherwise>
    </choose>
    
    <!--
     第一种情况：第一个when满足条件 where emp_name=?
     第二种情况：第二个when满足条件 where emp_salary < 3000
     第三种情况：两个when都不满足 where 1=1 执行了otherwise
     -->
</select>
```



#### 2.4.5 foreach标签

**基本用法**

用批量插入举例

```xml
<!--
    collection属性：要遍历的集合
    item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象
    separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符
    open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串
    close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串
    index属性：这里起一个名字，便于后面引用
        遍历List集合，这里能够得到List集合的索引值
        遍历Map集合，这里能够得到Map集合的key
 -->
<foreach collection="empList" item="emp" separator="," open="values" index="myIndex">
    <!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 -->
    (#{emp.empName},#{myIndex},#{emp.empSalary},#{emp.empGender})
</foreach>
```

**批量更新时需要注意**

上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：

```properties
atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true
```

示例

```xml
<!-- int updateEmployeeBatch(@Param("empList") List<Employee> empList) -->
<update id="updateEmployeeBatch">
    <foreach collection="empList" item="emp" separator=";">
        update t_emp set emp_name=#{emp.empName} where emp_id=#{emp.empId}
    </foreach>
</update>
```

**关于foreach标签的collection属性**

如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来：

```XML
Parameter 'empList' not found. Available parameters are [arg0, collection, list]
```

在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。

#### 2.4.6 sql片段

**抽取重复的SQL片段**

```XML
<!-- 使用sql标签抽取重复出现的SQL片段 -->
<sql id="mySelectSql">
    select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp
</sql>
```

引用已抽取的SQL片段

```XML
<!-- 使用include标签引用声明的SQL片段 -->
<include refid="mySelectSql"/>
```

#### 2.5 MyBatis高级拓展

##### 2.5.1 插件和分页插件PageHelper

##### 2.5.1.1 插件机制和PageHelper插件介绍

  MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。

  具体来说，MyBatis 的插件机制包括以下三个组件：

  1. `Interceptor`（拦截器）：定义一个拦截方法 `intercept`，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。
  2. `Invocation`（调用）：实际上是对被拦截的方法的封装，封装了 `Object target`、`Method method` 和 `Object[] args` 这三个字段。
  3. `InterceptorChain`（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。

  插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 `@Intercepts` 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。

  PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。下面就介绍一下 PageHelper 的使用方式。

  https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#如何配置数据库方言

##### 2.5.1.2 PageHelper插件使用
  1. pom.xml引入依赖

```XML
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>5.1.11</version>
</dependency>

```
  2. mybatis-config.xml配置分页插件

      在 MyBatis 的配置文件中添加 PageHelper 的插件：

```XML
<plugins>
    <plugin interceptor="com.github.pagehelper.PageInterceptor">
        <property name="helperDialect" value="mysql"/>
    </plugin>
</plugins>

```

      其中，`com.github.pagehelper.PageInterceptor` 是 PageHelper 插件的名称，`dialect` 属性用于指定数据库类型（支持多种数据库）
  3. 页插件使用

      在查询方法中使用分页：

```Java
@Test
public void testTeacherRelationshipToMulti() {

    TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class);
//第一个参数是 pageNum，表示要查询的页码
//第二个参数是 pageSize，表示每页显示的记录数  
    PageHelper.startPage(1,2);
    // 查询Customer对象同时将关联的Order集合查询出来
    List<Teacher> allTeachers = teacherMapper.findAllTeachers();
//
    PageInfo<Teacher> pageInfo = new PageInfo<>(allTeachers);

    System.out.println("pageInfo = " + pageInfo);
    long total = pageInfo.getTotal(); // 获取总记录数
    System.out.println("total = " + total);
    int pages = pageInfo.getPages();  // 获取总页数
    System.out.println("pages = " + pages);
    int pageNum = pageInfo.getPageNum(); // 获取当前页码
    System.out.println("pageNum = " + pageNum);
    int pageSize = pageInfo.getPageSize(); // 获取每页显示记录数
    System.out.println("pageSize = " + pageSize);
    List<Teacher> teachers = pageInfo.getList(); //获取查询页的数据集合
    System.out.println("teachers = " + teachers);
    teachers.forEach(System.out::println);

}
```

##### 2.5.2MyBatis高级拓展

逆向化工程MyBatisX使用

1. 安装插件：

    在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。
    
    

2.

1.连接数据库

![](E:\课程资料\springboot\黑马springboot\图片\x1.png)

2填写信息

![](E:\课程资料\springboot\黑马springboot\图片\x2.png)

3展示库表

![](E:\课程资料\springboot\黑马springboot\图片\x3.png)

4逆向工程使用

![](E:\课程资料\springboot\黑马springboot\图片\x4.png)

<img src="E:\课程资料\springboot\黑马springboot\图片\x5.png" style="zoom:150%;" />

3结果

![](E:\课程资料\springboot\黑马springboot\图片\x6.png)



## 3、mybatisPlus

### 3.1配置

```xml
<!--坐标 不需要额外导入mybatis依赖,mybatis-plus已经集成mybatis-->
  <!-- mybatis-plus  -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.3.1</version>
        </dependency>

        <!-- 数据库相关配置启动器 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>

        <!-- druid启动器的依赖  -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-3-starter</artifactId>
            <version>1.2.18</version>
        </dependency>

        <!-- 驱动类-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.28</version>
        </dependency>

```

```yaml
mybatis-plus:
  global-config:
    db-config:
      table-prefix: tbl_ #表前缀
      id-type: auto
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #日志
```

```yaml
# 连接池配置
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      url: jdbc:mysql:///day01
      username: root
      password: root
      driver-class-name: com.mysql.cj.jdbc.Driver
logging:
  level:
    root: info
    com.tulingxueyuan: debug  #设置日志级别 mp的mapper日志级别      

```

完善连接池配置：

文件夹：META-INF.spring

文件名：

org.springframework.boot.autoconfigure.AutoConfiguration.imports

内容：com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure

启动类

```java
@MapperScan("com.itruyan.mapper")
@SpringBootApplication
public class MainApplication {

    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class,args);
    }
    
}

```

### 3.2核心功能

#### 3.2.1基于Mapper接口CRUD

> 通用 CRUD 封装[BaseMapper (opens new window)](https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-core/src/main/java/com/baomidou/mybatisplus/core/mapper/BaseMapper.java)接口， `Mybatis-Plus` 启动时自动解析实体表关系映射转换为 `Mybatis` 内部对象注入容器! 内部包含常见的单表操作！

##### Insert方法

```Java
// 插入一条记录
// T 就是要插入的实体对象
// 默认主键生成策略为雪花算法（后面讲解）
int insert(T entity);
```

| 类型 | 参数名 | 描述     |
| ---- | ------ | -------- |
| T    | entity | 实体对象 |


##### Delete方法

```Java
// 根据 entity 条件，删除记录
int delete(@Param(Constants.WRAPPER) Wrapper<T> wrapper);

// 删除（根据ID 批量删除）
int deleteBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);

// 根据 ID 删除
int deleteById(Serializable id);

// 根据 columnMap 条件，删除记录
int deleteByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);
```

| 类型                               | 参数名    | 描述                                 |
| ---------------------------------- | --------- | ------------------------------------ |
| Wrapper<T>                         | wrapper   | 实体对象封装操作类（可以为 null）    |
| Collection<? extends Serializable> | idList    | 主键 ID 列表(不能为 null 以及 empty) |
| Serializable                       | id        | 主键 ID                              |
| Map<String, Object>                | columnMap | 表字段 map 对象                      |


##### Update方法

```Java
// 根据 whereWrapper 条件，更新记录
int update(@Param(Constants.ENTITY) T updateEntity, 
            @Param(Constants.WRAPPER) Wrapper<T> whereWrapper);

// 根据 ID 修改  主键属性必须值
int updateById(@Param(Constants.ENTITY) T entity);
```

| 类型       | 参数名        | 描述                                                         |
| ---------- | ------------- | ------------------------------------------------------------ |
| T          | entity        | 实体对象 (set 条件值,可为 null)                              |
| Wrapper<T> | updateWrapper | 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） |


##### Select方法

```Java
// 根据 ID 查询
T selectById(Serializable id);

// 根据 entity 条件，查询一条记录
T selectOne(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

// 查询（根据ID 批量查询）
List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable> idList);

// 根据 entity 条件，查询全部记录
List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

// 查询（根据 columnMap 条件）
List<T> selectByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);

// 根据 Wrapper 条件，查询全部记录
List<Map<String, Object>> selectMaps(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值
List<Object> selectObjs(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

// 根据 entity 条件，查询全部记录（并翻页）
IPage<T> selectPage(IPage<T> page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

// 根据 Wrapper 条件，查询全部记录（并翻页）
IPage<Map<String, Object>> selectMapsPage(IPage<T> page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);

// 根据 Wrapper 条件，查询总记录数
Integer selectCount(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
```

参数说明

| 类型                               | 参数名       | 描述                                     |
| ---------------------------------- | ------------ | ---------------------------------------- |
| Serializable                       | id           | 主键 ID                                  |
| Wrapper<T>                         | queryWrapper | 实体对象封装操作类（可以为 null）        |
| Collection<? extends Serializable> | idList       | 主键 ID 列表(不能为 null 以及 empty)     |
| Map<String, Object>                | columnMap    | 表字段 map 对象                          |
| IPage<T>                           | page         | 分页查询条件（可以为 RowBounds.DEFAULT） |


##### 自定义和多表映射

mybatis-plus的默认mapperxml位置

```YAML
mybatis-plus: # mybatis-plus的配置
  # 默认位置 private String[] mapperLocations = new String[]{"classpath*:/mapper/**/*.xml"};    
  mapper-locations: classpath:/mapper/*.xml
```

自定义mapper方法：

```Java
public interface UserMapper extends BaseMapper<User> {

    //正常自定义方法！
    //可以使用注解@Select或者mapper.xml实现
    List<User> queryAll();
}

```

基于mapper.xml实现：

```XML
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace = 接口的全限定符 -->
<mapper namespace="com.atguigu.mapper.UserMapper">

   <select id="queryAll" resultType="user" >
       select * from user
   </select>
</mapper>
```

#### 3.2.2基于Service接口CRUD

通用 Service CRUD 封装[IService (opens new window)](https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java)接口，进一步封装 CRUD 采用 `get 查询单行` `remove 删除` `list 查询集合` `page 分页` 前缀命名方式区分 `Mapper` 层避免混淆，

##### 对比Mapper接口CRUD区别：

- service添加了批量方法
- service层的方法自动添加事务

##### 使用Iservice接口方式

接口继承IService接口

```Java
public interface UserService extends IService<User> {
}

```

类继承ServiceImpl实现类

```Java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper,User> implements UserService{

}

```

说明:

- 通用 Service CRUD 封装[IService (opens new window)](https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java)接口，进一步封装 CRUD 采用 `get 查询单行` `remove 删除` `list 查询集合` `page 分页` 前缀命名方式区分 `Mapper` 层避免混淆，
- 泛型 `T` 为任意实体对象
- 建议如果存在自定义通用 Service 方法的可能，请创建自己的 `IBaseService` 继承 `Mybatis-Plus` 提供的基类
- 对象 `Wrapper` 为 [条件构造器](https://baomidou.com/pages/10c804/)

##### Save

```java
// 插入一条记录（选择字段，策略插入）
boolean save(T entity);
// 插入（批量）
boolean saveBatch(Collection<T> entityList);
// 插入（批量）
boolean saveBatch(Collection<T> entityList, int batchSize);
```

|     类型      |   参数名   |     描述     |
| :-----------: | :--------: | :----------: |
|       T       |   entity   |   实体对象   |
| Collection<T> | entityList | 实体对象集合 |
|      int      | batchSize  | 插入批次数量 |

batchSize:每次执行多少条，例如提交了100条，设置batchSize=20，则每次执行20条，直到执行完100条

##### SaveOrUpdate

```java
// TableId 注解属性值存在则更新记录，否插入一条记录
boolean saveOrUpdate(T entity);
// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法
boolean saveOrUpdate(T entity, Wrapper<T> updateWrapper);
// 批量修改插入
boolean saveOrUpdateBatch(Collection<T> entityList);
// 批量修改插入
boolean saveOrUpdateBatch(Collection<T> entityList, int batchSize);
```

|     类型      |    参数名     |               描述               |
| :-----------: | :-----------: | :------------------------------: |
|       T       |    entity     |             实体对象             |
|  Wrapper<T>   | updateWrapper | 实体对象封装操作类 UpdateWrapper |
| Collection<T> |  entityList   |           实体对象集合           |
|      int      |   batchSize   |           插入批次数量           |

batchSize:每次执行多少条，例如提交了100条，设置batchSize=20，则每次执行20条，直到执行完100条

##### Remove

```java
// 根据 queryWrapper 设置的条件，删除记录
boolean remove(Wrapper<T> queryWrapper);
// 根据 ID 删除
boolean removeById(Serializable id);
// 根据 columnMap 条件，删除记录
boolean removeByMap(Map<String, Object> columnMap);
// 删除（根据ID 批量删除）
boolean removeByIds(Collection<? extends Serializable> idList);
```

|                类型                |    参数名    |          描述           |
| :--------------------------------: | :----------: | :---------------------: |
|             Wrapper<T>             | queryWrapper | 实体包装类 QueryWrapper |
|            Serializable            |      id      |         主键 ID         |
|        Map<String, Object>         |  columnMap   |     表字段 map 对象     |
| Collection<? extends Serializable> |    idList    |      主键 ID 列表       |

##### Update

```java
// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset
boolean update(Wrapper<T> updateWrapper);
// 根据 whereWrapper 条件，更新记录
boolean update(T updateEntity, Wrapper<T> whereWrapper);
// 根据 ID 选择修改
boolean updateById(T entity);
// 根据ID 批量更新
boolean updateBatchById(Collection<T> entityList);
// 根据ID 批量更新
boolean updateBatchById(Collection<T> entityList, int batchSize);
```

| 类型          | 参数名        | 描述                             |
| ------------- | ------------- | -------------------------------- |
| Wrapper<T>    | updateWrapper | 实体对象封装操作类 UpdateWrapper |
| T             | entity        | 实体对象                         |
| Collection<T> | entityList    | 实体对象集合                     |
| nt            | batchSize     | 更新批次数量                     |

batchSize:每次执行多少条，例如提交了100条，设置batchSize=20，则每次执行20条，直到执行完100条

##### Get

```java
// 根据 ID 查询
T getById(Serializable id);
// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last("LIMIT 1")
T getOne(Wrapper<T> queryWrapper);
// 根据 Wrapper，查询一条记录
T getOne(Wrapper<T> queryWrapper, boolean throwEx);
// 根据 Wrapper，查询一条记录
Map<String, Object> getMap(Wrapper<T> queryWrapper);
// 根据 Wrapper，查询一条记录
<V> V getObj(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);
```

|            类型             |    参数名    |              描述               |
| :-------------------------: | :----------: | :-----------------------------: |
|        Serializable         |      id      |             主键 ID             |
|         Wrapper<T>          | queryWrapper | 实体对象封装操作类 QueryWrapper |
|           boolean           |   throwEx    |   有多个 result 是否抛出异常    |
|              T              |    entity    |            实体对象             |
| Function<? super Object, V> |    mapper    |            转换函数             |

##### List

```java
// 查询所有
List<T> list();
// 查询列表
List<T> list(Wrapper<T> queryWrapper);
// 查询（根据ID 批量查询）
Collection<T> listByIds(Collection<? extends Serializable> idList);
// 查询（根据 columnMap 条件）
Collection<T> listByMap(Map<String, Object> columnMap);
// 查询所有列表
List<Map<String, Object>> listMaps();
// 查询列表
List<Map<String, Object>> listMaps(Wrapper<T> queryWrapper);
// 查询全部记录
List<Object> listObjs();
// 查询全部记录
<V> List<V> listObjs(Function<? super Object, V> mapper);
// 根据 Wrapper 条件，查询全部记录
List<Object> listObjs(Wrapper<T> queryWrapper);
// 根据 Wrapper 条件，查询全部记录
<V> List<V> listObjs(Wrapper<T> queryWrapper, Function<? super Object, V> mapper);
```

|                类型                |    参数名    |              描述               |
| :--------------------------------: | :----------: | :-----------------------------: |
|             Wrapper<T>             | queryWrapper | 实体对象封装操作类 QueryWrapper |
| Collection<? extends Serializable> |    idList    |          主键 ID 列表           |
|        Map<String, Object>         |  columnMap   |         表字段 map 对象         |
|    Function<? super Object, V>     |    mapper    |            转换函数             |

##### Page

```java
// 无条件分页查询
IPage<T> page(IPage<T> page);
// 条件分页查询
IPage<T> page(IPage<T> page, Wrapper<T> queryWrapper);
// 无条件分页查询
IPage<Map<String, Object>> pageMaps(IPage<T> page);
// 条件分页查询
IPage<Map<String, Object>> pageMaps(IPage<T> page, Wrapper<T> queryWrapper);
```

|    类型    |    参数名    |              描述               |
| :--------: | :----------: | :-----------------------------: |
|  IPage<T>  |     page     |            翻页对象             |
| Wrapper<T> | queryWrapper | 实体对象封装操作类 QueryWrapper |

##### Count

```java
//自3.4.3.2开始,返回值修改为long
// 查询总记录数
long count();
// 根据 Wrapper 条件，查询总记录数
long count(Wrapper<T> queryWrapper);
```

|    类型    |    参数名    |              描述               |
| :--------: | :----------: | :-----------------------------: |
| Wrapper<T> | queryWrapper | 实体对象封装操作类 QueryWrapper |

##### Chain

```java
//query
// 链式查询 普通
QueryChainWrapper<T> query();
// 链式查询 lambda 式。注意：不支持 Kotlin
LambdaQueryChainWrapper<T> lambdaQuery();

// 示例：
query().eq("column", value).one();
lambdaQuery().eq(Entity::getId, value).list();



//update
// 链式更改 普通
UpdateChainWrapper<T> update();
// 链式更改 lambda 式。注意：不支持 Kotlin
LambdaUpdateChainWrapper<T> lambdaUpdate();

// 示例：
update().eq("column", value).remove();
lambdaUpdate().eq(Entity::getId, value).update(entity);
```

#### 3.2.3、分页

1 导入分页插件

```java
@Configuration
@MapperScan("scan.your.mapper.package")
public class MybatisPlusConfig {

    /**
     * 添加分页插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));//如果配置多个插件,切记分页最后添加
        //interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); 如果有多数据源可以不配具体类型 否则都建议配上具体的DbType
        return interceptor;
    }
}
```

| **属性名** | **类型** | **默认值** |                           **描述**                           |
| :--------: | :------: | :--------: | :----------------------------------------------------------: |
|  overflow  | boolean  |   false    | 溢出总页数后是否进行处理(默认不处理,参见 `插件#continuePage` 方法) |
|  maxLimit  |   Long   |            |  单页分页条数限制(默认无限制,参见 `插件#handlerLimit` 方法)  |
|   dbType   |  DbType  |            | 数据库类型(根据类型获取应使用的分页方言,参见 `插件#findIDialect` 方法) |
|  dialect   | IDialect |            |          方言实现类(参见 `插件#findIDialect` 方法)           |

2 使用分页查询

```java
@Test
public void testPageQuery(){
    //设置分页参数 参数一：当前页码 参数二：每页显示的记录数
    Page<User> page = new Page<>(1, 5);
    userMapper.selectPage(page, null);
    //获取分页数据
    List<User> list = page.getRecords();
    list.forEach(System.out::println);
    System.out.println("当前页："+page.getCurrent());
    System.out.println("每页显示的条数："+page.getSize());
    System.out.println("总记录数："+page.getTotal());
    System.out.println("总页数："+page.getPages());
    System.out.println("是否有上一页："+page.hasPrevious());
    System.out.println("是否有下一页："+page.hasNext());
}
```

3 自定义的mapper方法使用分页

方法

```Java
//传入参数携带Ipage接口
//返回结果为IPage
IPage<User> selectPageVo(IPage<?> page, Integer id);
// or (class MyPage extends Ipage<UserVo>{ private Integer state; })
MyPage selectPageVo(MyPage page);
// or
List<UserVo> selectPageVo(IPage<UserVo> page, Integer id);
```

接口实现

```Java
<select id="selectPageVo" resultType="xxx.xxx.xxx.User">
    SELECT * FROM user WHERE id > #{id}
</select>
```

测试

```Java
@Test
public void testQuick(){
//当前页 每页记录数
    IPage page = new Page(1,2);
//查询id为2的记录，结果每页显示两条，当前是第一页
    userMapper.selectPageVo(page,2);

    long current = page.getCurrent();
    System.out.println("当前页current = " + current);
    long pages = page.getPages();
    System.out.println("总页数pages = " + pages);
    long total = page.getTotal();
    System.out.println("总记录数total = " + total);
    List records = page.getRecords();
    System.out.println("数据列表records = " + records);

}
```

Page

> 该类继承了 `IPage` 类，实现了 `简单分页模型` 如果你要实现自己的分页模型可以继承 `Page` 类或者实现 `IPage` 类

|         属性名         |  类型   |  默认值   |                             描述                             |
| :--------------------: | :-----: | :-------: | :----------------------------------------------------------: |
|        records         |  List   | emptyList |                         查询数据列表                         |
|         total          |  Long   |     0     |                       查询列表总记录数                       |
|          size          |  Long   |    10     |                   每页显示条数，默认 `10`                    |
|        current         |  Long   |     1     |                            当前页                            |
|         orders         |  List   | emptyList | 排序字段信息，允许前端传入的时候，注意 SQL 注入问题，可以使用 `SqlInjectionUtils.check(...)` 检查文本 |
|    optimizeCountSql    | boolean |   true    | 自动优化 COUNT SQL 如果遇到 `jSqlParser` 无法解析情况，设置该参数为 `false` |
| optimizeJoinOfCountSql | boolean |   true    |         自动优化 COUNT SQL 是否把 join 查询部分移除          |
|      searchCount       | boolean |   true    | 是否进行 count 查询，如果只想查询到列表不要查询总记录数，设置该参数为 `false` |
|        maxLimit        |  Long   |           |                       单页分页条数限制                       |
|        countId         | String  |           | `xml` 自定义 `count` 查询的 `statementId` 也可以不用指定在分页 `statementId` 后面加上 `_mpCount` 例如分页 `selectPageById` 指定 count 的查询 `statementId` 设置为 `selectPageById_mpCount` 即可默认找到该 `SQL` 执行 |

#### 3.2.4、条件构造器

##### 3.2.4.1条件构造器继承结构

![](E:\课程资料\springboot\黑马springboot\图片\条件构造器继承结构.png)

##### 3.2.4.2queryWrapper组装条件



组装查询条件：![](E:\课程资料\springboot\黑马springboot\图片\mybatisPlus条件构造器.png)

```Java
@Test
public void test01(){
    //查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息
    //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    queryWrapper.like("username", "a")
            .between("age", 20, 30)
            .isNotNull("email");
    List<User> list = userMapper.selectList(queryWrapper);
    list.forEach(System.out::println);

```

组装排序条件:

```Java
@Test
public void test02(){
    //按年龄降序查询用户，如果年龄相同则按id升序排列
    //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    queryWrapper
            .orderByDesc("age")
            .orderByAsc("id");
    List<User> users = userMapper.selectList(queryWrapper);
    users.forEach(System.out::println);
}
```

组装删除条件:

```Java
@Test
public void test03(){
    //删除email为空的用户
    //DELETE FROM t_user WHERE (email IS NULL)
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    queryWrapper.isNull("email");
    //条件构造器也可以构建删除语句的条件
    int result = userMapper.delete(queryWrapper);
    System.out.println("受影响的行数：" + result);
}
```

and和or关键字使用(修改)：

```Java
@Test
public void test04() {
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改
    //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age > ? OR email IS NULL)
    queryWrapper
            .like("username", "a")
            .gt("age", 20)
            .or()
            .isNull("email");
    User user = new User();
    user.setAge(18);
    user.setEmail("user@atguigu.com");
    int result = userMapper.update(user, queryWrapper);
    System.out.println("受影响的行数：" + result);
}
```

指定列映射查询：

```Java
@Test
public void test05() {
    //查询用户信息的username和age字段
    //SELECT username,age FROM t_user
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    queryWrapper.select("username", "age");
    //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null
    List<Map<String, Object>> maps = userMapper.selectMaps(queryWrapper);
    maps.forEach(System.out::println);
}
```

condition判断组织条件:

```Java
 @Test
public void testQuick3(){
    
    String name = "root";
    int    age = 18;

    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    //判断条件拼接
    //当name不为null拼接等于, age > 1 拼接等于判断
    //方案1: 手动判断
    if (!StringUtils.isEmpty(name)){
        queryWrapper.eq("name",name);
    }
    if (age > 1){
        queryWrapper.eq("age",age);
    }
    
    //方案2: 拼接condition判断
    //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!
    //eq(condition,列名,值)
    queryWrapper.eq(!StringUtils.isEmpty(name),"name",name)
            .eq(age>1,"age",age);   
}
```

##### 3.2.4.3UpdateWrapper

使用queryWrapper:

```Java
@Test
public void test04() {
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改
    //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age > ? OR email IS NULL)
    queryWrapper
            .like("username", "a")
            .gt("age", 20)
            .or()
            .isNull("email");
    User user = new User();
    user.setAge(18);
    user.setEmail("user@atguigu.com");
    int result = userMapper.update(user, queryWrapper);
    System.out.println("受影响的行数：" + result);
}
```

注意：使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！

使用updateWrapper:

```Java
@Test
public void testQuick2(){

    UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();
    //将id = 3 的email设置为null, age = 18
    updateWrapper.eq("id",3)
            .set("email",null)  // set 指定列和结果
            .set("age",18);
    //如果使用updateWrapper 实体对象写null即可!
    int result = userMapper.update(null, updateWrapper);
    System.out.println("result = " + result);

}
```

使用updateWrapper可以随意设置列的值！！

##### 3.2.4.4LambdaQueryWrapper

1. **LambdaQueryWrapper对比QueryWrapper优势**

QueryWrapper 示例代码：

```Java
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
queryWrapper.eq("name", "John")
  .ge("age", 18)
  .orderByDesc("create_time")
  .last("limit 10");
List<User> userList = userMapper.selectList(queryWrapper);
```

LambdaQueryWrapper 示例代码：

```Java
LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();

lambdaQueryWrapper.eq(User::getName, "John")
  .ge(User::getAge, 18)
  .orderByDesc(User::getCreateTime)
  .last("limit 10");
List<User> userList = userMapper.selectList(lambdaQueryWrapper);
```

从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 `User::getName`、`User::getAge`），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。



2. **lambda表达式回顾**

Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。

Lambda 表达式的语法可以分为以下几个部分：

1. **参数列表：** 参数列表用小括号 `()` 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。

    示例：`(a, b)`, `x ->`, `() ->`
2. **箭头符号：** 箭头符号 `->` 分割参数列表和 Lambda 表达式的主体部分。

    示例：`->`
3. **Lambda 表达式的主体：** Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 `{}` 括起来，并且需要明确指定 return 关键字。

    示例：

    - 单个表达式：`x -> x * x`
    - 代码块：`(x, y) -> { int sum = x + y; return sum; }`

Lambda 表达式的语法可以更具体地描述如下：

```Java
// 使用 Lambda 表达式实现一个接口的方法
interface Greeting {
    void sayHello();
}

public class LambdaExample {
    public static void main(String[] args) {
    
        //原始匿名内部类方式
        Greeting greeting = new Greeting() {
            @Override
            public void sayHello(int a) {
                System.out.println("Hello, world!");
            }
        };
        
        a->System.out.println("Hello, world!")
        
        // 使用 Lambda 表达式实现接口的方法
        greeting = () -> System.out.println("Hello, world!");

          System.out::println;
           () ->  类.XXX(); -> 类：：方法名
        // 调用接口的方法
        greeting.sayHello();
    }
}
```

**3. 方法引用回顾:**

方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。

Java 8 支持以下几种方法引用的形式：

1. **静态方法引用：** 引用静态方法，语法为 `类名::静态方法名`。
2. **实例方法引用：** 引用实例方法，语法为 `实例对象::实例方法名`。
3. **对象方法引用：** 引用特定对象的实例方法，语法为 `类名::实例方法名`。
4. **构造函数引用：** 引用构造函数，语法为 `类名::new`。

演示代码:

```Java
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class MethodReferenceExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Tom", "Alice");
        // 使用 Lambda 表达式
        names.forEach(name -> System.out.println(name));
        // 使用方法引用
        names.forEach(System.out::println);
    }
}
```

**4. lambdaQueryWrapper使用案例:**

```Java
@Test
public void testQuick4(){

    String name = "root";
    int    age = 18;

    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!
    //eq(condition,列名,值)
    queryWrapper.eq(!StringUtils.isEmpty(name),"name",name)
            .eq(age>1,"age",age);

    //TODO: 使用lambdaQueryWrapper
    LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();
    //注意: 需要使用方法引用
    //技巧: 类名::方法名
    lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name);
    List<User> users= userMapper.selectList(lambdaQueryWrapper);
    System.out.println(users);
}
```

##### 3.2.4.5LambdaUpdateWrapper

使用案例:

```Java
@Test
public void testQuick2(){

    UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();
    //将id = 3 的email设置为null, age = 18
    updateWrapper.eq("id",3)
            .set("email",null)  // set 指定列和结果
            .set("age",18);

    //使用lambdaUpdateWrapper
    LambdaUpdateWrapper<User> updateWrapper1 = new LambdaUpdateWrapper<>();
    updateWrapper1.eq(User::getId,3)
            .set(User::getEmail,null)
            .set(User::getAge,18);
    
    //如果使用updateWrapper 实体对象写null即可!
    int result = userMapper.update(null, updateWrapper);
    System.out.println("result = " + result);
}
```

#### 3.2.5注解

1. 理解和介绍

    MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。

    MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。

    理解：

```Java
public interface UserMapper extends BaseMapper<User> {

}
```

    此接口对应的方法为什么会自动触发 user表的crud呢？
    
    默认情况下， 根据指定的<实体类>的名称对应数据库表名，属性名对应数据库的列名！
    
    但是不是所有数据库的信息和实体类都完全映射！
    
    例如： 表名 t_user  → 实体类 User 这时候就不对应了！
    
    自定义映射关系就可以使用mybatis-plus提供的注解即可！
2. @TableName注解
    - 描述：表名注解，标识实体类对应的表
    - 使用位置：实体类

```Java
@TableName("sys_user") //对应数据库表名
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
}

```

    特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！
    
    其他解决方案：全局设置前缀 ([https://www.baomidou.com/pages/56bac0/#基本配置](https://www.baomidou.com/pages/56bac0/#基本配置))

```YAML
mybatis-plus: # mybatis-plus的配置
  global-config:
    db-config:
      table-prefix: sys_ # 表名前缀字符串
```
3. @TableId 注解
    - 描述：主键注解
    - 使用位置：实体类主键字段

```Java
@TableName("sys_user")
public class User {
    @TableId(value="主键列名",type=主键策略)
    private Long id;
    private String name;
    private Integer age;
    private String email;
}

```

| 属性  | 类型   | 必须指定 | 默认值      | 描述         |
| ----- | ------ | -------- | ----------- | ------------ |
| value | String | 否       | ""          | 主键字段名   |
| type  | Enum   | 否       | IdType.NONE | 指定主键类型 |

idType属性可选值

| 值                | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| AUTO              | 数据库 ID 自增 (mysql配置主键自增长)                         |
| ASSIGN_ID（默认） | 分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口`IdentifierGenerator`的方法`nextId`(默认实现类为`DefaultIdentifierGenerator`雪花算法) |


    全局配置修改主键策略:

```yaml
mybatis-plus:
  configuration:
    # 配置MyBatis日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      # 配置MyBatis-Plus操作表的默认前缀
      table-prefix: t_
      # 配置MyBatis-Plus的主键策略
      id-type: auto
```

    在以下场景下，添加`@TableId`注解是必要的：
    
    1. 实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用`@TableId`注解来指定实体类中表示主键的字段。
    2. 主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加`@TableId`注解，并通过`value`属性指定生成策略。
4. 雪花算法使用场景

    雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。

    在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。

    雪花算法生成的ID是一个64位的整数，由以下几个部分组成：

    1. 时间戳：41位，精确到毫秒级，可以使用69年。
    2. 节点ID：10位，用于标识分布式系统中的不同节点。
    3. 序列号：12位，表示在同一毫秒内生成的不同ID的序号。

    通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。

    雪花算法的工作方式如下：

    1. 当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。
    2. 节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。
    3. 序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。

    需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。

    雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。

    **你需要记住的: 雪花算法生成的数字,需要使用Long 或者 String类型主键!!**
5. @TableField

    描述：字段注解（非主键）

```Java
@TableName("sys_user")
public class User {
    @TableId
    private Long id;
    @TableField("nickname")
    private String name;
    private Integer age;
    private String email;
}
```

| 属性  |  类型   | 必须指定 | 默认值 |        描述        |
| :---: | :-----: | :------: | :----: | :----------------: |
| value | String  |    否    |   ""   |    数据库字段名    |
| exist | boolean |    否    |  true  | 是否为数据库表字段 |

**MyBatis-Plus会自动开启驼峰命名风格映射!!!**

### 3.3、高级拓展

#### 3.3.1逻辑删除

**逻辑删除实现:**

1. 数据库和实体类添加逻辑删除字段
    1. 表添加逻辑删除字段

        可以是一个布尔类型、整数类型或枚举类型。

```SQL
ALTER TABLE USER ADD deleted INT DEFAULT 0 ;  # int 类型 1 逻辑删除 0 未逻辑删除
```
    2. 实体类添加逻辑删除属性

```SQL
@Data
public class User {

   // @TableId
    private Integer id;
    private String name;
    private Integer age;
    private String email;
    
    @TableLogic
    //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 
    private Integer deleted;
}

```
2. 指定逻辑删除字段和属性值
    1. 单一指定

```SQL
@Data
public class User {

   // @TableId
    private Integer id;
    private String name;
    private Integer age;
    private String email;
     @TableLogic
    //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 
    private Integer deleted;
}
```
    2. 全局指定

```YAML
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
```
3. 演示逻辑删除操作

    > 逻辑删除以后,没有真正的删除语句,删除改为修改语句!

    删除代码:

```Java
//逻辑删除
@Test
public void testQuick5(){
    //逻辑删除
    userMapper.deleteById(5);
}
```

    执行效果:
    
    JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@5871a482] will not be managed by Spring
==> Preparing: UPDATE user SET deleted=1 WHERE id=? AND deleted=0
==> Parameters: 5(Integer)
<==    Updates: 1
4. 测试查询数据

```Java
@Test
public void testQuick6(){
    //正常查询.默认查询非逻辑删除数据
    userMapper.selectList(null);
}

//SELECT id,name,age,email,deleted FROM user WHERE deleted=0
```

## 4、druid

```xml
<!--坐标-->
<dependency>
   <groupId>com.alibaba</groupId>
   <artifactId>druid-spring-boot-starter</artifactId>
   <version>1.2.1</version>
</dependency>

```



```yaml
spring:
  datasource:
    # 连接池类型 
    type: com.alibaba.druid.pool.DruidDataSource

    # Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下!
    druid:
      url: jdbc:mysql://localhost:3306/day01
      username: root
      password: root
      driver-class-name: com.mysql.cj.jdbc.Driver
      # 初始化时建立物理连接的个数
      initial-size: 5
      # 连接池的最小空闲数量
      min-idle: 5
      # 连接池最大连接数量
      max-active: 20
      # 获取连接时最大等待时间，单位毫秒
      max-wait: 60000
      # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。
      test-while-idle: true
      # 既作为检测的间隔时间又作为testWhileIdel执行的依据
      time-between-eviction-runs-millis: 60000
      # 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间)
      min-evictable-idle-time-millis: 30000
      # 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual)
      validation-query: select 1
      # 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true
      test-on-borrow: false
      # 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true
      test-on-return: false
      # 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。
      pool-prepared-statements: false
      # 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100
      max-pool-prepared-statement-per-connection-size: -1
      # 合并多个DruidDataSource的监控数据
      use-global-data-source-stat: true

logging:
  level:
    root: debug
```

通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件，需要手动在resources目录下创建META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下!

```yaml
com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure
```

## 5、maven

## 6、servlet



# 二.项目开发

## 1、注解

### 1.1启动类注解

#### @SpringBootApplication

* 位置：类

* **SpringBoot最核心的注解**，用于SpringBoot的主类，标识这是一个 SpringBoot 应用，用来开启 Spring Boot 的各项能力
  是 @SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解的组合。由于这些注解一般一起使用，所以干脆整合成了一个统一的注解@SpringBootApplication。

#### @SpringBootConfiguration

* 位置：类

* 继承@Configuration注解，主要用于加载配置文件，二者功能致，标注当前类为配置类， 将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，且实例名为方法名

#### @EnableAutoConfiguration

* 位置：类

* 开启自动配置功能，帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。智能的自动配置功效借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持

#### @ComponentScan

* 位置：类

* 扫描包 @ComponentScan("com.itruyan.config")

### 1.2配置文件相关注解

#### @Configuration

* 标明为配置类,标注在类上

@Configuration(proxyBeanMethods = true)

|      属性名      | 属性值 |                             描述                             |
| :--------------: | :----: | :----------------------------------------------------------: |
| proxyBeanMethods |  true  | Full模式,保证每个**@Bean**方法被调用多少次返回的组件都是单实例的 |
| proxyBeanMethods | false  | Lite模式,每个**@Bean**方法被调用多少次返回的组件都是新创建的 |

* 注意:组件依赖必须使用**Full**模式默认。其他默认是否**Lite**模式,当需要摆脱组件依赖时才使用**lite**模式,*使用**lite**模式可以快速启动和构建项  目，因为**full**模式下需要扫描实例

#### @ComponentScan

* 位置:类

* 组件扫描。让spring Boot扫描到Configuration类并把它加入到程序上下文。

* @ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring容器中。

### 1.3注入bean

#### @Bean

* 位置：注解类型，方法

* 产生一个bean的**方法**，交给Spring容器管理。支持别名@Bean(“xx-name”)

#### @Component

* 位置：类、接口、枚举或注解类型
* 把普通pojo实例化到spring容器

#### @Controller

* 位置：类、接口、枚举或注解类型
* 用于标注控制层。这里控制层里面的每个方法，都可以去调用@Service标识的类

#### @Service

* 位置：类、接口、枚举或注解类型
* 注入dao，用于标注服务层(业务逻辑层)，主要用来进行业务的逻辑处理

#### @Repository

* 位置：类、接口、枚举或注解类型
* 实现dao访问，用于标注数据访问层（Dao层/持久层），也可以说用于标注数据访问组件，即DAO组件

#### @Scope

* ElementType.*TYPE*, ElementType.METHOD

* @Scope在和@Component注解一起修饰在类上，作为类级别注解时，@Scope表示该类实例的范围
* 在和@Bean一起修饰在方法上，作为方法级别注解时，@Scope表示该方法返回的实例的范围
* 对于@Scope注解，我们常用的属性一般就是：**value**和**proxyMode**，value就是指明作用域范围，proxyMode指明哪种作用域代理

| 属性1：value |                       描述                       | 属性2：proxyMode |                 描述                  |
| :----------: | :----------------------------------------------: | :--------------: | :-----------------------------------: |
|  singleton   |               bean是单例的。(默认)               |     DEFAULT      |          不使用代理。(默认)           |
|  prototype   | bean是多例的，即每次使用该bean时都会新建一个对象 |        NO        |       不使用代理，等价于DEFAULT       |
|   request    |      在一次http请求中，一个bean对应一个实例      |    INTERFACES    | 使用基于接口的代理(jdk dynamic proxy) |
|   session    |    在一个httpSession中，一个bean对应一个实例     |   TARGET_CLASS   |        使用基于类的代理(cglib)        |

例 @Scope(value = "session",proxyMode = ScopedProxyMode.*DEFAULT*)

#### @Entity

* ElementType.TYPE
* 实体类注解
* @Table(name =“数据库表名”)，这个注解也注释在实体类上，对应数据库中相应的表
* @Id、@Column注解用于标注实体类中的字段，pk字段标注为@Id，其余@Column

#### @Autowired

* ElementType.*CONSTRUCTOR*, ElementType.*METHOD*, ElementType.*PARAMETER*, ElementType.*FIELD*, ElementType.ANNOTATION_TYPE
* 自动导入
* @Autowired注解作用在构造函数、方法、方法参数、类字段以及注解上
* @Autowired注解可以实现Bean的自动注入

#### @Qualifier

* ElementType.*FIELD*, ElementType.*METHOD*, ElementType.*PARAMETER*, ElementType.*TYPE*, ElementType.ANNOTATION_TYPE
* 当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用

### 1.4表述层相关注解

#### @Controller

* 位置：类、接口、枚举或注解类型
* 用于标注控制层。这里控制层里面的每个方法，都可以去调用@Service标识的类

#### @CrossOrigin

* ElementType.*TYPE*, ElementType.*METHOD*
* 允许跨域访问
* 属性origins 
* 标注在类上 表示该类所有方法允许跨域
* 标注在方法上 表示该方法可以跨域访问
* **默认配置**： 如果不配置具体的属性，`@CrossOrigin` 会启用默认的 CORS，通常允许所有来源、方法和头，但不允许发送凭据
* **预检请求（Preflighted Requests）**： 如果请求方法是 `OPTIONS`，浏览器会先发送一个预检请求（OPTIONS），询问是否允许跨域。如果服务器配置了 `@CrossOrigin`，它需要处理这个预检请求并返回允许信息

属性

|      属性名      |                             描述                             |
| :--------------: | :----------------------------------------------------------: |
|  allowedOrigins  | 指定允许的请求来源，可以是一个或多个值，如 `"*"`（允许所有源）、`"http://example.com"` 或 `["http://example.com", "https://example2.com"]` |
|  allowedMethods  |      允许的方法类型，如 `GET`, `POST`, `PUT`, `DELETE`       |
|  allowedHeaders  |       允许的请求头，如 `Content-Type`, `Authorization`       |
| allowCredentials |            是否允许发送凭据（如 cookies 或 JWT）             |
|      maxAge      |         预检请求（OPTIONS）的缓存时间（以秒为单位）          |



#### @RestController 复合注解

* ElementType.TYPE
* @RestController注解= **@ResponseBody+@Controller**,将方法返回的对象直接在浏览器上展示成json格

#### @ResponseBody

* ElementType.*TYPE*, ElementType.*METHOD*
* 将该方法的返回值直接作为响应报文的响应体响应到浏览器，**返回json类型数据**

#### @RequestMapping

* ElementType.*TYPE*, ElementType.*METHOD*
* 将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上,提供路由信息，负责URL到Controller中的具体函数的映射
* **写访问路径**

**属性1：** value 写访问路径

| 属性2：method |              描述               |
| :-----------: | :-----------------------------: |
|     *GET*     |                                 |
|    *HEAD*     |                                 |
|    *POST*     |                                 |
|     *PUT*     |                                 |
|    *PATCH*    |                                 |
|   *DELETE*    | method = RequestMethod.*DELETE* |
|   *OPTIONS*   |                                 |
|    *TRACE*    |                                 |

更多功能

* 匹配正则表达式

```java
@RequestMapping(value = "/user/{username: [a-zA-Z0-9]+}/blog/{blogId}")
```



#### @GetMapping

* ElementType.*METHOD*
* @RequestMapping(method = **RequestMethod.GET**)的缩写
* 将HTTP get请求映射到特定处理程序的方法注解
* 用于方法上写访问路径

#### @PostMapping

* ElementType.*METHOD*
* @RequestMapping(method = **RequestMethod.POST**)的缩写
* 将HTTP post请求映射到特定处理程序的方法注解
* 用于方法上写访问路径

#### @PutMapping

* ElementType.*METHOD*
* @RequestMapping(method = **RequestMethod.PUT**)的缩写
* 将HTTP put请求映射到特定处理程序的方法注解
* 用于方法上写访问路径

#### @DeleteMapping

* ElementType.*METHOD*
* @RequestMapping(method = **RequestMethod.DELETE**)的缩写
* 将HTTP delete请求映射到特定处理程序的方法注解
* 用于方法上写访问路径

### 1.5获取请求参数注解

#### @PathVariable

- **原始方式**：`/deleteUser?id=1`
- **rest方式**：`/deleteUser/1`
- @PathVariable Map<String,String> pv获取所有路径参数，并且自动装配到map集合 id=1,以键值的方式存储

```html
http://localhost:8080/testRest/1/admin
```

```java
@RequestMapping("/testRest/{id}/{username}")
public String testRest(@PathVariable("id") String id, @PathVariable("username") String username){
    System.out.println("id:"+id+",username:"+username);
    return "success";
}
//最终输出的内容为-->id:1,username:admin
```

#### @RequestParam

```txt
https://www/user?id=1&name=admin
```

```java
@RequestMapping(value="/user")
	public String getUserBlog(@RequestParam(value="id") int blogId,@RequestParam(value="name") String name) {
		return "blogId="+blogId+",name"=name;
	}
//blogId=1,name=admin
```

|     属性     |    取值    |                             描述                             |
| :----------: | :--------: | :----------------------------------------------------------: |
|    value     |            |               指定为形参赋值的请求参数的参数名               |
|   required   | true/false | 若设置为true时，则当前请求必须传输value所指定的请求参数，有defaultValue时不会报错；false不需要 |
| defaultValue |            | 当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值 |

奇怪的知识：获取所有请求参数@RequestParam Map<String,String> params,不要指定名字

#### @RequestBody

* ElementType.*PARAMETER*
* 当前请求的请求体会为当前注解所标识的形参赋值,**接收json类型数据或者把json转为实体类**

#### @RequestHeader

* ElementType.PARAMETER
* 将请求头中的参数值映射到控制器的参数中
* @RequestHeader Map<String,String> header 指定名称就获取指定的请求头，不指定就获取所有请求头

|     属性     |    取值    |                             描述                             |
| :----------: | :--------: | :----------------------------------------------------------: |
|    value     |            |               指定为形参赋值的请求参数的参数名               |
|   required   | true/false | 若设置为true时，则当前请求必须传输value所指定的请求参数，有defaultValue时不会报错；false不需要 |
| defaultValue |            | 当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值 |

#### @RequestAttribute

* ElementType.*PARAMETER*
* 获取request域属性   request.setAttribute("msg","没有bug，完美运行")  @RequestAttribute("msg") String msg

|     属性     |    取值    |                             描述                             |
| :----------: | :--------: | :----------------------------------------------------------: |
|    value     |            |               指定为形参赋值的请求参数的参数名               |
|   required   | true/false | 若设置为true时，则当前请求必须传输value所指定的请求参数，有defaultValue时不会报错；false不需要 |
| defaultValue |            | 当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值 |

#### @ModelAttribute

* ElementType.*PARAMETER*, ElementType.*METHOD*
* 在同一个控制器中，标注了@ModelAttribute的方法实际上会在@RequestMapping方法之前被调用
* 预设全局数据

使用@ModelAttribute可以在controller请求前存入数据

```java
// 1.无返回值方法,放入Model,自定义 key ,value
@ModelAttribute()
public void presetParam(Model model) {
    model.addAttribute("globalAttr", "我是全局参数");
}
// 2.不有指定name,返回值方法,返回值是map,int等,key就是map,int等,,value是返回值
@ModelAttribute()
public Map<String, String> presetParam2() {
    Map<String, String> map1 = new HashMap<String, String>();
    map1.put("key1", "value1");
    return map1;
}
// 3.指定name,返回值方法,key就是name,value是返回值
@ModelAttribute(name = "map2")
public Map<String, String> presetParam3() {
    Map<String, String> map = new HashMap<String, String>();
    map.put("key2", "value2");
    return map;
}
// 4.可以接受请求参数
@ModelAttribute()
public void presetParam4(@RequestParam("name") String name,Model model) {
    model.addAttribute("name", name);
}


```

取出数据:

```java
 //1.使用Model取出
@GetMapping("model")
public String methodOne(Model model) {
    Map<String, Object> modelMap = model.asMap();
    System.out.println(modelMap.get("name").toString()); // 传入name的值    
    return modelMap.get("globalAttr").toString();
}
//2.使用ModelMap取出
@GetMapping("modelMap")
public String methodThree(ModelMap modelMap) {
    return modelMap.get("map").toString();
}
//3.@ModelAttribute()指定key,直接取出
@GetMapping("modelAttribute")
public String methodTwo(@ModelAttribute("map2") Map map2) {
    return map2.toString();
}

```



#### @MatrixVariable

* ElementType.*PARAMETER*
* 矩阵变量

```
/cars/sell;low=34;brand=byd,audi,yd
```

```java
//矩阵变量 路径中有 ;
//cars/sell;low=34;brand=byd,audi,yd
//注意 请求路径是/cars/sell,但是路径需要写成这样/cars/{path},后面的是矩阵变量,springboot默认是禁止使用矩阵变量
//矩阵变量必须有url路径变量才能被解析
    @GetMapping("/cars/{path}")
    public Map carsSell(@MatrixVariable("low") Integer low,
                        @MatrixVariable("brand") List<String> brand, 
                        @PathVariable("path") String path){
        Map<String,Object> map = new HashMap<>();

        map.put("low",low);
        map.put("brand",brand);
        map.put("path",path);
        return map;
    }

    // /boss/1;age=20/2;age=10

    @GetMapping("/boss/{bossId}/{empId}")
    public Map boss(@MatrixVariable(value = "age",pathVar = "bossId") Integer bossAge,
                    @MatrixVariable(value = "age",pathVar = "empId") Integer empAge){
        Map<String,Object> map = new HashMap<>();

        map.put("bossAge",bossAge);
        map.put("empAge",empAge);
        return map;
//返回结果 {"bossAge":20,"empAge":10}
    }
```

* 开启矩阵变量

```java
@Configuration(proxyBeanMethods = false)
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        //开启矩阵变量
        UrlPathHelper urlPathHelper = new UrlPathHelper();
        //把移除 ; 功能去掉,这样矩阵变量就可以生效了
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    }
}
```

#### @CookieValue

* ElementType.*PARAMETER*
* 把Request header中关于cookie的值绑定到方法的参数上

#### 可以获取参数但不是注解

##### RequestEntity

RequestEntity**封装请求报文的一种类型**，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过`getHeaders()`获取请求头信息，通过`getBody()`获取请求体信息

```java
@RequestMapping("/testRequestEntity")
public String testRequestEntity(RequestEntity<String> requestEntity){
    System.out.println("requestHeader:"+requestEntity.getHeaders());
    System.out.println("requestBody:"+requestEntity.getBody());
    return "success";
}
//requestHeader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"http://localhost:8080", user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"]
//requestBody:username=admin&password=123

```

##### ResponseEntity

用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文

### 1.6读取配置文件的值

#### @Value

* ElementType.*FIELD*, ElementType.*METHOD*, ElementType.*PARAMETER*, ElementType.*ANNOTATION_TYPE*
* 绑定配置文件的属性值

```java
@Component
public class MyComponent {

    @Value("${example.name}")
    private String name;

    @Value("${example.age}")
    private int age;

    void{
        System.out.println(name+","+age);
        //输出结果John,30
    }
}
```

```yml
example:
  name: John
  age: 30
```



#### @ConfigurationProperties

* ElementType.*TYPE*, ElementType.*METHOD*
* 将配置文件的属性绑定到类或者方法上

```java
@Component
@ConfigurationProperties(prefix = "example")
public class MyConfiguration {

    private String name;

    private int age;

    void{
        System.out.println(name+","+age);
        //输出结果John,30
    }
}
```

```yml
example:
  name: John
  age: 30
```

### 1.7导入配置文件

#### @PropertySource

* ElementType.*TYPE*

```java
//引入单个properties文件
@PropertySource(value = {"classpath : xxxx/xxx.properties"})

//引入多个properties文件
@PropertySource(value = {"classpath : xxxx/xxx.properties"，"classpath : xxxx.properties"})

//与@ConfigurationProperties配合：@PropertySource可以与@ConfigurationProperties注解一起使用，将属性文件中的属性映射到配置类的字段中
@Configuration
@ConfigurationProperties(prefix = "config")
@PropertySource("classpath:config.properties")
public class AppConfig {
    // ...
}
```

#### @ImportResource

可以额外分为两种模式 相对路径classpath，绝对路径（真实路径）file

注意：单文件可以不写value或locations，value和locations都可用

相对路径（classpath）

```java
//引入单个xml配置文件
@ImportSource("classpath : xxx/xxxx.xml")
//引入多个xml配置文件
@ImportSource(locations={"classpath : xxxx.xml" , "classpath : yyyy.xml"})
```

绝对路径（file）

```java
//引入单个xml配置文件
@ImportSource(locations= {"file : d:/hellxz/dubbo.xml"})
//引入多个xml配置文件
@ImportSource(locations= {"file : d:/hellxz/application.xml" , "file : d:/hellxz/dubbo.xml"})
```

取值：使用@Value注解取配置文件中的值

```java
@Value("${properties中的键}")
private String xxx;
```

#### @Import 

**导入单个配置类**

```java
@Configuration
@Import(OtherConfig.class)
public class AppConfig {
    // 这里可以使用OtherConfig中定义的bean
}
```

**导入多个配置类**

```java
@Configuration
@Import({OtherConfig1.class, OtherConfig2.class})
public class AppConfig {
    // 这里可以使用OtherConfig1和OtherConfig2中定义的bean
}
```

**导入带有条件判断的配置类**

```java
@Configuration
@Import(value = {MyImportSelector.class})
public class AppConfig {
    // 根据条件判断是否导入ConditionalConfig中定义的bean
}

public class MyImportSelector implements ImportSelector {

    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 在这里根据条件决定是否导入某个配置类
        boolean condition = true; // 假设条件为真，实际情况根据需求而定
        if (condition) {
            // 如果条件为真，则导入某个配置类
            return new String[]{"com.example.MyConfiguration"};
        } else {
            // 如果条件为假，则不导入任何配置类
            return new String[]{};
        }
    }
}
```

**使用ImportSelector导入配置类**

```java
@Configuration
@Import(MyImportSelector.class)
public class AppConfig {
    // MyImportSelector中根据条件选择性地导入配置类
}

public class MyImportSelector implements ImportSelector {

    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 在这里根据条件决定是否导入某个配置类
        boolean condition = true; // 假设条件为真，实际情况根据需求而定
        if (condition) {
            // 如果条件为真，则导入某个配置类
            return new String[]{"com.example.MyConfiguration"};
        } else {
            // 如果条件为假，则不导入任何配置类
            return new String[]{};
        }
    }
}
```

### 1.8全局异常处理

#### @ControllerAdvice

* ElementType.*TYPE*
* 增强指定的controller
* 可以包含`@ExceptionHandler`、`@InitBinder`和`@ModelAttribute`方法，用于全局处理异常、数据绑定和模型属性等。这些全局控制器建言会在所有`@Controller`标注的类执行前生效，可以为整个应用程序的控制器提供统一的处理逻辑
* `@ControllerAdvice`标注的类优先于`@Controller`标注的类执行

1.指定包

```java
//匹配com.xzh.cn包及其子包下的所有Controller
@ControllerAdvice(basePackages="com.xzh.cn")
//数组形式指定
@ControllerAdvice(basePackages={"com.xzh.cn", "com.xzh.cn.controller"}),

```

2.指定注解

```java
//匹配所有被这个注解修饰的 Controller，也可以匹配自定义的注解
@ControllerAdvice（annotations={RestController.class})
```

3.指定类

```java
// 指定增强S001LoginController和S002LogoutController
@ControllerAdvice(assignableTypes = {S001LoginController.class, S002LogoutController.class})
```

注意：如果不写则增强所有Controller

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ServiceException.class)//表明该方法用来处理ServiceException类型的异常
    @ResponseBody
    public Result handle(ServiceException se){
        return Result.error(se.getCode(),se.getMessage());
    }

    @ExceptionHandler(value = Exception.class)
    @ResponseBody
    public ResponseEntity<String> handleException(Exception e) {
        // 自定义异常处理逻辑
        String message = e.getMessage();
        //检查 e 是否是 ServiceException（或其子类）的一个实例,是就返回true
        if(!(e instanceof ServiceException)) {

            e.printStackTrace();
        }
        if (message.contains("(using password: YES)")) {
            if (!message.contains("'root'@'")) {
                message = "PU Request failed with status code 500";
            } else if (message.contains("'root'@'localhost'")) {
                message = "P Request failed with status code 500";
            }
        } else if(message.contains("Table") && message.contains("doesn't exist")) {
            message = "T Request failed with status code 500";
        } 
        .......
        return new ResponseEntity<>(message, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```



#### @ExceptionHandler

* ElementType.*METHOD*
* 用于方法上，指定异常类型，出现该异常后执行该方法,搭配@ControllerAdvice使用

@ExceptionHandler(ServiceException.class)

@ExceptionHandler(xxxException.class)

```java
//处理BindException异常信息
@ExceptionHandler(BindException.class)
@ResponseBody
public Result exceptionHandler(BindException e, BindingResult result) {
   //逻辑处理
   return new Result();
}

//通用异常处理器,所有Exception异常都由这里处理
@ExceptionHandler(Exception.class)
@ResponseBody
public Result exceptionHandler(Exception e) {
    return new Result();
}

```

#### @RestControllerAdvice

@RestControllerAdvice = @ControllerAdvice + @ResponseBody



#### @InitBinder

* ElementType.*METHOD*
* 用于请求参数预处理

使用默认的属性编辑器:

```java
@InitBinder
public void initBinder(WebDataBinder dataBinder) {
    /*
     * 创建一个字符串微调编辑器
     * 参数{boolean emptyAsNull}: 是否把空字符串("")视为 null
     */
    StringTrimmerEditor trimmerEditor = new StringTrimmerEditor(true);
    /*
     * 注册自定义编辑器
     * 接受两个参数{Class<?> requiredType, PropertyEditor propertyEditor}
     * requiredType：所需处理的类型
     * propertyEditor：属性编辑器，StringTrimmerEditor就是 propertyEditor的一个子类
     */
    dataBinder.registerCustomEditor(String.class, trimmerEditor);
    //日期格式的字符串转换成Date对象
    dataBinder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"), false));
    dataBinder.addValidators(paramVOValidator);
}

```

自定义属性编辑器:

```java
/**
 * @description:  防止xss注入
 * @params:  String类型转换，将所有传递进来的String进行HTML编码，防止XSS攻击
 */
//@InitBinder
protected void initBinder2(WebDataBinder binder) {
    //自定义属性编辑器 PropertyEditorSupport
    binder.registerCustomEditor(String.class, new PropertyEditorSupport() {
        @Override
        public void setAsText(String text) {
            setValue(text == null ? null : StringEscapeUtils.escapeHtml4(text.trim()));
        }
        @Override
        public String getAsText() {
            Object value = getValue();
            return value != null ? value.toString() : "";
        }
    });
}

```

自定义参数校验 @Validated：

```java
@Data
public class User implements Serializable {

    @ApiModelProperty("age")
    private Integer age;
    
    @ApiModelProperty("name")
    private String name;
}



@Component
public class UserValidator implements Validator {

	/**
	* @description:  满足条件才往下走
	* @params:
	* @return:
	*/
    @Override
    public boolean supports(Class<?> clazz) {
        // 只支持ParamVO类型对象的校验
        return User.class.equals(clazz);
    }

    /**
    * @description:  自定义校验规则
    * @params:
    * @return:
    */
    @Override
    public void validate(Object target, Errors errors) {
        User user = (User) target;
        String userName = user.getName();
        if (StringUtils.isEmpty(userName) || userName.length() < 8) {
            errors.rejectValue("name", "valid.userNameLen", new Object[]{"minLength", 8}, "用户名不能少于8位");
        }
    }
}




@Autowired
private UserValidator userValidator;
@InitBinder
public void initBinder(WebDataBinder dataBinder) {
    dataBinder.addValidators(userValidator);
}
```



#### @ModelAttribute

* ElementType.*PARAMETER*, ElementType.*METHOD*
* 在同一个控制器中，标注了@ModelAttribute的方法实际上会在@RequestMapping方法之前被调用
* 预设全局数据

使用@ModelAttribute可以在controller请求前存入数据

```java
// 1.无返回值方法,放入Model,自定义 key ,value
@ModelAttribute()
public void presetParam(Model model) {
    model.addAttribute("globalAttr", "我是全局参数");
}
// 2.不有指定name,返回值方法,返回值是map,int等,key就是map,int等,,value是返回值
@ModelAttribute()
public Map<String, String> presetParam2() {
    Map<String, String> map1 = new HashMap<String, String>();
    map1.put("key1", "value1");
    return map1;
}
// 3.指定name,返回值方法,key就是name,value是返回值
@ModelAttribute(name = "map2")
public Map<String, String> presetParam3() {
    Map<String, String> map = new HashMap<String, String>();
    map.put("key2", "value2");
    return map;
}
// 4.可以接受请求参数
@ModelAttribute()
public void presetParam4(@RequestParam("name") String name,Model model) {
    model.addAttribute("name", name);
}


```

取出数据:

```java
 //1.使用Model取出
@GetMapping("model")
public String methodOne(Model model) {
    Map<String, Object> modelMap = model.asMap();
    System.out.println(modelMap.get("name").toString()); // 传入name的值    
    return modelMap.get("globalAttr").toString();
}
//2.使用ModelMap取出
@GetMapping("modelMap")
public String methodThree(ModelMap modelMap) {
    return modelMap.get("map").toString();
}
//3.@ModelAttribute()指定key,直接取出
@GetMapping("modelAttribute")
public String methodTwo(@ModelAttribute("map2") Map map2) {
    return map2.toString();
}

```

### 1.9AOP和tx



### 1.n通用

#### @Target

* 该注解是java.lang包下的，用于自定义注解是指定使用位置

例@Target(ElementType.*ANNOTATION_TYPE*)

|            属性             |                描述                |
| :-------------------------: | :--------------------------------: |
| ElementType.ANNOTATION_TYPE |         可以应用于注解类型         |
|   ElementType.CONSTRUCTOR   |         可以应用于构造方法         |
|      ElementType.FIELD      |   可以应用于字段（包括枚举常量）   |
| ElementType.LOCAL_VARIABLE  |         可以应用于局部变量         |
|     ElementType.METHOD      |           可以应用于方法           |
|     ElementType.PACKAGE     |            可以应用于包            |
|    ElementType.PARAMETER    |        可以应用于方法的参数        |
|      ElementType.TYPE       | 可以应用于类、接口、枚举或注解类型 |

#### @ConditionalOnBean

* 位置：类、接口、枚举、注解类型、方法

* @ConditionalOnMissingBean(name = "tom") 当容器中**有**名为tom的bean时执行该类/接口/枚举/注解/方法

#### @ConditionalOnMissingBean

* 位置：类、接口、枚举、注解类型、方法

* @ConditionalOnMissingBean(name = "tom") 当容器中**没有**名为tom的bean时执行该类/接口/枚举/注解/方法

#### @EnableConfigurationProperties

* 位置：类、接口、枚举、注解
* @EnableConfigurationProperties(Car.class)相当于给Car类添加了@Component

#### @PostConstruct

* 方法
* Spring容器在创建该Bean实例并注入完所有依赖之后，会自动调用被标注方法，执行其中的逻辑
* 讲白了，就是最早执行的方法

## 2、AOP

### 2.1JDK动态代理

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class JDKProxy {
    public static void main(String[] args) {
        //静态代理
       UserService userServiceProxy = new UserServiceImplStaticProxy();
       userServiceProxy.findName();
       System.out.println("---------------------");
        //动态代理
       UserService userService = new UserServiceImpl();
       UserServiceImplDynamicProxy userServiceImplProxy = new UserServiceImplDynamicProxy();
       UserService result = (UserService)userServiceImplProxy.get(userService);
       result.findName();
    }
}

interface UserService{
    public abstract void findName();
}
/**
 * 方案一：静态代理 缺点：如果目标方法有多个方法，那么就要实现多个方法，代码复用性低且难以管理
 * */
//目标类
class UserServiceImpl implements UserService{

    @Override
    public void findName() {
        System.out.println("柳如烟");
    }
}
//代理对象
class UserServiceImplStaticProxy implements UserService{
    private UserServiceImpl userService = new UserServiceImpl();
    @Override
    public void findName() {
        //逻辑增强
        System.out.println("寻找目标");
        userService.findName();
    }
}
/**
 * 方案二：动态代理
 * */
//代理对象
class UserServiceImplDynamicProxy implements InvocationHandler{
    private Object object;
    public Object get(Object o){
        this.object = o;
        return Proxy.newProxyInstance(this.object.getClass().getClassLoader(), this.object.getClass().getInterfaces(),this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //增强逻辑
        System.out.println("寻找目标");
        return method.invoke(this.object,args);
    }
}


```

### 2.2springboot Aop,基于注解

#### 2.2.1依赖

```xml
<!-- spring-aspects会帮我们传递过来aspectjweaver -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>6.0.6</version>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>6.0.6</version>
</dependency>
```

#### 2.2.2开启aspectj注解支持

```java
@Configuration
@ComponentScan(basePackages = "com.atguigu")
//作用等于 <aop:aspectj-autoproxy /> 配置类上开启 Aspectj注解支持!
@EnableAspectJAutoProxy
public class MyConfig {
}
//pringboot2之后不再需要添加该注解，因为已经默认启用
```

#### 2.2.3注解

##### @EnableAspectJAutoProxy

* ElementType.*TYPE*

* 开启AspectJ自动代理,springboot2之后不再需要添加该注解，因为已经默认启用

##### @Aspect

* ElementType.*TYPE*
* 声明切面类，表示这个类是一个切面类，讲白了就是做代理的那个类
* 属性：value 指定切面名称，可以省略不写

##### @Order

* ElementType.*TYPE*, ElementType.*METHOD*, ElementType.*FIELD*
* 设置切面的优先级,数字越小级别越高

##### @Pointcut

* ElementType.*METHOD*
* 提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可

引用

```java
// 切入点表达式重用
@Pointcut("execution(public int com.atguigu.aop.api.Calculator.add(int,int)))")
public void declarPointCut() {}

//同类中引用
@Before(value = "declarPointCut()")
public void printLogBeforeCoreOperation(JoinPoint joinPoint) {

//不同类中使用
@Before(value = "com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()")
public Object roundAdvice(ProceedingJoinPoint joinPoint) {
```

统一管理

```java
@Component
public class AtguiguPointCut {
    
    @Pointcut(value = "execution(public int *..Calculator.sub(int,int))")
    public void atguiguGlobalPointCut(){}
    
    @Pointcut(value = "execution(public int *..Calculator.add(int,int))")
    public void atguiguSecondPointCut(){}
    
    @Pointcut(value = "execution(* *..*Service.*(..))")
    public void transactionPointCut(){}
}
```

属性

|                      value                       |                           argNames                           |
| :----------------------------------------------: | :----------------------------------------------------------: |
| 用于指定切点表达式，表示在哪些连接点上触发该通知 | 用于指定通知方法的参数名，可以在通知方法中通过这些参数名来获取对应的参数值 |

##### @Before

* ElementType.*METHOD*
* AOP前置通知,在被代理的目标方法前执行

属性

|                      value                       |                           argNames                           |
| :----------------------------------------------: | :----------------------------------------------------------: |
| 用于指定切点表达式，表示在哪些连接点上触发该通知 | 用于指定通知方法的参数名，可以在通知方法中通过这些参数名来获取对应的参数值 |

```java
@Before(value = "execution(* com.example.service.MyService.myMethod(..))", argNames = "param1, param2")
```

##### @AfterReturning

* ElementType.*METHOD*
* AOP返回通知,在被代理的目标方法成功结束后执行（寿终正寝）

属性

|                      value                       |                           argNames                           |
| :----------------------------------------------: | :----------------------------------------------------------: |
| 用于指定切点表达式，表示在哪些连接点上触发该通知 | 用于指定通知方法的参数名，可以在通知方法中通过这些参数名来获取对应的参数值 |

```java
@AfterReturning(value = "execution(* com.example.service.MyService.myMethod(..))", argNames = "param1, param2")
```

##### @AfterThrowing

* ElementType.*METHOD*
* AOP异常通知,在被代理的目标方法异常结束后执行（死于非命）

属性

|                      value                       |                           argNames                           |
| :----------------------------------------------: | :----------------------------------------------------------: |
| 用于指定切点表达式，表示在哪些连接点上触发该通知 | 用于指定通知方法的参数名，可以在通知方法中通过这些参数名来获取对应的参数值 |

```java
@AfterThrowing(value = "execution(* com.example.service.MyService.myMethod(..))", argNames = "param1, param2")
```

##### @After

* ElementType.*METHOD*
* AOP后置通知,在被代理的目标方法最终结束后执行（盖棺定论）

属性

|                      value                       |                           argNames                           |
| :----------------------------------------------: | :----------------------------------------------------------: |
| 用于指定切点表达式，表示在哪些连接点上触发该通知 | 用于指定通知方法的参数名，可以在通知方法中通过这些参数名来获取对应的参数值 |

```java
@After(value = "execution(* com.example.service.MyService.myMethod(..))", argNames = "param1, param2")
```

##### @Around

* ElementType.*METHOD*
* AOP环绕通知,环绕通知对应整个 try...catch...finally 结构，包括前面四种通知的所有功能

属性

|                      value                       |                           argNames                           |
| :----------------------------------------------: | :----------------------------------------------------------: |
| 用于指定切点表达式，表示在哪些连接点上触发该通知 | 用于指定通知方法的参数名，可以在通知方法中通过这些参数名来获取对应的参数值 |

```java
@Around(value = "execution(* com.example.service.MyService.myMethod(..))", argNames = "param1, param2")
```

示例

```java
// 使用@Around注解标明环绕通知方法
@Around(value = "com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()")
public Object manageTransaction(
    
        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，
        // Spring会将这个类型的对象传给我们
        ProceedingJoinPoint joinPoint) {
    
    // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组
    Object[] args = joinPoint.getArgs();
    
    // 通过ProceedingJoinPoint对象获取目标方法的签名对象
    Signature signature = joinPoint.getSignature();
    
    // 通过签名对象获取目标方法的方法名
    String methodName = signature.getName();
    
    // 声明变量用来存储目标方法的返回值
    Object targetMethodReturnValue = null;
    
    try {
    
        // 在目标方法执行前：开启事务（模拟）
        log.debug("[AOP 环绕通知] 开启事务，方法名：" + methodName + "，参数列表：" + Arrays.asList(args));
    
        // 过ProceedingJoinPoint对象调用目标方法
        // 目标方法的返回值一定要返回给外界调用者
        targetMethodReturnValue = joinPoint.proceed(args);
    
        // 在目标方法成功返回后：提交事务（模拟）
        log.debug("[AOP 环绕通知] 提交事务，方法名：" + methodName + "，方法返回值：" + targetMethodReturnValue);
    
    }catch (Throwable e){
    
        // 在目标方法抛异常后：回滚事务（模拟）
        log.debug("[AOP 环绕通知] 回滚事务，方法名：" + methodName + "，异常：" + e.getClass().getName());
    
    }finally {
    
        // 在目标方法最终结束后：释放数据库连接
        log.debug("[AOP 环绕通知] 释放数据库连接，方法名：" + methodName);
    
    }
    
    return targetMethodReturnValue;
}
```



#### 2.2.4切点表达式

##### 1切点表达式作用

<img src="E:\课程资料\springboot\黑马springboot\图片\切点表达式的作用.png" style="zoom: 200%;" />

##### 2切点表达式

###### 2.1语法

**动作关键词(访问修饰符 返回值 包名.类/接口名 .方法名(参数)异常名)**

改图基于execution,并且少了第八位异常名称

![](E:\课程资料\springboot\黑马springboot\图片\切点表达式语法.png)

语法细节

通配符

`*` 代表单个独立的任意符号，可以独立出现，也可做为前缀或后缀匹配符

```java
execution(public * com.llg.*.UserService.find* (*))
```

`. .`即多个连续的任意符号，可独立出现，常用于简化包名与参数的书写

```java
execution(public User com..UserService.findById(..))
```

`+` 用于专门用于匹配子类类型

```java
execution(* *..*Service+.*(..))
```

* 第一位：动作关键词
* 第二位：方法访问修饰符,public、private等可以省略

```java
public private 直接描述对应修饰符即可
```

* 第三位：方法返回值

```java
int String void 直接描述返回值类型
```

​	  注意：

​	  特殊情况 不考虑 访问修饰符和返回值

​	  execution(* * ) 这是错误语法

​	  execution(*) == 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了

* 第四位：指定包的地址

```java
 固定的包: com.atguigu.api | service | dao
 单层的任意命名: com.atguigu.*  = com.atguigu.api  com.atguigu.dao  * = 任意一层的任意命名
 任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!
 注意: ..不能用作包开头   public int .. 错误语法  com..
 找到任何包下: *..
```

* 第五位：指定类名称

```java
固定名称: UserService
任意类名: *
部分任意: com..service.impl.*Impl
任意包任意类: *..*
```

* 第六位：指定方法名称

```java
语法和类名一致
任意访问修饰符,任意类的任意方法: * *..*.*
```

* 第七位：方法参数

```java
第七位: 方法的参数描述
       具体值: (String,int) != (int,String) 没有参数 ()
       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识
       部分具体和模糊:
         第一个参数是字符串的方法 (String..)
         最后一个参数是字符串 (..String)
         字符串开头,int结尾 (String..int)
         包含int类型(..int..)
```

* 第八位：异常名,图中没有给出来,方法定义中抛出指定异常，可以省略

###### 2.2execution

功能最强最完整，最精确

- 匹配所有的不带参数的add()方法

  ```java
  execution(* add())
  ```

- 匹配所有抛出Exception的方法

  ```java
  execution(* *(..) throws Exception)
  ```

###### 2.3within

根据一个类来匹配，**这个类中的所有方法将被匹配为切点**，并被拦截增强

- 匹配UserServiceImpl类对应对象的所有方法外部调用，而且这个对象只能是UserServiceImpl类型，不能是其子类型

  ```java
  within(com.llg.service.UserServiceImpl)
  ```

- 匹配com.elim包及其子包下面所有的类的所有方法的外部调用

  ```java
  within(com.elim..*)
  ```

###### 2.4args

按方法的参数匹配，即**增强形参符合表达式的方法**

- 匹配并增强任何不带参数的方法

  ```java
  args()
  ```

- 匹配并增强带任意个参数的方法（等于是全员增强了）

  ```java
  args(..)
  ```

- 匹配并增强只有一个形参，且类型为String的方法

  ```java
  args(java.lang.String)
  ```

- 匹配并增强形参有任意个，但第一个类型为String的方法

  ```java
  args(java.lang.String,..)
  ```

- 匹配并增强形参有任意个，但最后一个参数为String类型的方法

  ```jav
  args(..,java.lang.String)
  ```

###### 2.5bean

按bean去匹配，**只要是这个bean在调用的方法，就做AOP增强**

- 匹配Spring Bean容器中id或name为myBean的bean，并增强它调用的所有方法

  ```jav
  bean(myBean)
  ```

- 匹配所有id或name为以user开头的bean，并增强它调用的所有方法

  ```java
  bean(user*)
  ```

###### 2.6this

当生成的**代理对象**，可以转型为type这个类型时，匹配成功

Spring AOP基于代理实现，先看下整个流程:

* 1 Spring容器启动
* 2 读取所有切面配置中的切入点
* 3 初始化bean，判断bean对应的类中的方法是否匹配到任意切入点
  * 匹配失败，创建对象
  * 匹配成功，创建原始对象（目标对象）的代理对象
* 4 获取bean执行方法
  * 获取bean，调用方法并执行，完成操作
  * 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强内容，完成操作

即，Spring容器初始化Bena时，发现bean对应的类中有切点时，就不再创建原始对象了，而是创建这个类的对象的代理对象，**切点表达式中的this就是指这个代理对象**

语法：this(type)

* 当生成的代理对象，可以转型为type这个类型时，匹配成功

  ```java
  this(com.service.IUserService)
  ```

  * 匹配生成的代理对象是IUserService类型的所有方法的外部调用

###### 2.7target

**被代理的目标对象可以被转换为指定的类型**时，匹配成功，和this相反

```java
target(com.service.IUserService)
```

* 匹配生成的代理对象是IUserService类型的所有方法的外部调用

###### 2.8@annotation

根据注解来匹配，**被指定注解标注的方法**

* 匹配被@AutoFill标注的方法,切点表达式需要写注解的全类名

  ```java
  @annotation(com.sky.annotation.AutoFill)
  ```

获取注解的值

```java
@Aspect
@Component
@Slf4j
public class AutoFillAspect {
    //切入点
    @Pointcut("@annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut(){}
   
    //前置通知
    @Before(value = "autoFillPointCut()")
    public void autoFill(JoinPoint joinPoint)  {
        log.info("公共字段自动填充");
        //方法签名对象
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        //获取方法上的注解对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);
        //获取AutoFill的值
        OperationType operationType = autoFill.value();
}
```

###### 2.9@args

**按参数的类型的类上的注解匹配**，当某方法的形参类型的类上有指定的注解，则匹配成功

```java
@args(com.sun.MyAnnotation)
```

当有个方法method(MyParam param），它形参的类型为MyParam，MyParam类上有@MyAnnotation注解时匹配成功，增强method方法

###### 2.10@target

和args、@args类似，当被代理的目标对象**及**其父类型上拥有指定的注解时，匹配成功

```java
@target(com.sun.MyAnnotation)
```

被代理的目标对象被@MyAnnotation标注时，匹配成功

###### 2.11@within

匹配被代理的目标对象**或**其父类型拥有指定的注解，父类没有的方法不会被匹配

```java
@within(com.spring.service.MyAnnotation)
```

举个例子：

```java
@MyAnnotation
class A {
	void method a();
}
```

B类继承A类，且有做为子类特有的方法b

```java
class B extends A{
	
	void method b();
}
```

此时，

```java
new A().a()  匹配
new B().b()  不匹配
new B().a()	 匹配
子类B重写方法a后再调用：
new B().a()  不匹配
```

##### 3表达式组合

```java
@Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
//com.sky.mapper包下所有类的所有被@AutoFill注解标记的方法

@Pointcut("execution(* com.sky.mapper.*.*(..)) && within(com.sky.service..*) && @annotation(com.sky.annotation.AutoFill)")
//匹配在 com.sky.mapper 包下的所有方法，这些方法也在 com.sky.service 包下，并且带有 @AutoFill 注解

@Pointcut("execution(* com.sky.mapper.*.*(..)) || within(com.sky.service..*)")
//匹配在 com.sky.mapper 包下的所有方法或在 com.sky.service 包下的所有方法

@Pointcut("serviceMethods() && !serviceMethods2()")
//排除serviceMethods2()方法
```

##### 4管理切点表达式

将切点表达式统一存储到一个类中进行集中管理和维护！

```java
@Component
public class AtguiguPointCut {
    
@Pointcut(value = "execution(public int *..Calculator.sub(int,int))")
public void atguiguGlobalPointCut(){}
    
@Pointcut(value = "execution(public int *..Calculator.add(int,int))")
public void atguiguSecondPointCut(){}
    
@Pointcut(value = "execution(* *..*Service.*(..))")
public void transactionPointCut(){}
}
```

##### 5引用

```java
// 切入点表达式重用
@Pointcut("execution(public int com.atguigu.aop.api.Calculator.add(int,int)))")
public void declarPointCut() {}

//同类中引用
@Before(value = "declarPointCut()")
public void printLogBeforeCoreOperation(JoinPoint joinPoint) {

//不同类中使用
@Before(value = "com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()")
public Object roundAdvice(ProceedingJoinPoint joinPoint) {
```



#### 2.2.5Spring Aop实现

###### 1底层技术组成

![](E:\课程资料\springboot\黑马springboot\图片\AOP底层.png)

* 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）
* cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口
* AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解

JDK动态代理与CGLIB的区别

* JDK动态代理只提供接口的代理，不支持类的代理
  * JDK会在运行时为目标类生成一个动态代理类Sproxy*.class
  * 该代理类是实现了接目标类接口，并且代理类会实现接口所有的方法增强代码
  * 调用时通过代理类先去调用处理类进行增强，再通过反射的方式进行调用目标方法。从而实现AOP

* 如果代理类没有实现 接口，那么SpringAOP会选择使用CGLIB来动态代理目标类
  * CGLIB的底层是通讨ASM在运行时动态的生成目标举的一个子类，(还有其他相关举，要是为增强调用时效率)会牛成多个
  * 并且会重写父类所有的方法增强代码
  * 调用时先通过代理类进行增强，再直接调用父类对应的方法进行调用目标方法。从而实现AOP
    * CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为fnal，那么它是无法使用CGLIB做动态代理的
    * CGLIB 除了生成目标子类代理类，还有一个FastClass(路由类)，可以(但不是必须)让本类方法调用进行增强，而不会像idk代理那样本类方法调用增强会失效

###### 2简单实现

21.导入依赖

```xml
<!-- spring-aspects会帮我们传递过来aspectjweaver -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>6.0.6</version>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>6.0.6</version>
</dependency>
```

2.2开启aspectj注解支持

```java
@Configuration
@ComponentScan(basePackages = "com.atguigu")
//作用等于 <aop:aspectj-autoproxy /> 配置类上开启 Aspectj注解支持!
@EnableAspectJAutoProxy
public class MyConfig {
}
//pringboot2之后不再需要添加该注解，因为已经默认启用
```

2.3准备接口

```java
public interface Calculator {
    
    int add(int i, int j);
    
    int sub(int i, int j);
    
    int mul(int i, int j);
    
    int div(int i, int j);
    
}
```

2.4纯净实现

```java
package com.atguigu.proxy;


/**
 * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!
 */
@Component
public class CalculatorPureImpl implements Calculator {
    
    @Override
    public int add(int i, int j) {
    
        int result = i + j;
    
        return result;
    }
    
    @Override
    public int sub(int i, int j) {
    
        int result = i - j;
    
        return result;
    }
    
    @Override
    public int mul(int i, int j) {
    
        int result = i * j;
    
        return result;
    }
    
    @Override
    public int div(int i, int j) {
    
        int result = i / j;
    
        return result;
    }
}
```

2.4声明切面类

```java
package com.atguigu.advice;

import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

// @Aspect表示这个类是一个切面类
@Aspect
// @Component注解保证这个切面类能够放入IOC容器
@Component
public class LogAspect {
        
    // @Before注解：声明当前方法是前置通知方法
    // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上
    @Before(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")
    public void printLogBeforeCore() {
        System.out.println("[AOP前置通知] 方法开始了");
    }
    
    @AfterReturning(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")
    public void printLogAfterSuccess() {
        System.out.println("[AOP返回通知] 方法成功返回了");
    }
    
    @AfterThrowing(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")
    public void printLogAfterException() {
        System.out.println("[AOP异常通知] 方法抛异常了");
    }
    
    @After(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")
    public void printLogFinallyEnd() {
        System.out.println("[AOP后置通知] 方法最终结束了");
    }
    
}
```

2.5测试效果

```java
//@SpringJUnitConfig(locations = "classpath:spring-aop.xml")
@SpringJUnitConfig(value = {MyConfig.class})
public class AopTest {

    @Autowired
    private Calculator calculator;

    @Test
    public void testCalculator(){
        calculator.add(1,1);
    }
}

```

2.6输出结果

```java
"C:\Program Files\Java\jdk-17\bin\java.exe" -ea -Didea.test.cyclic.buffer.size=1048576 "-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2022.3.2\lib\idea_rt.jar=65511:D:\Program Files\JetBrains\IntelliJ IDEA 2022.3.2\bin" -Dfile.encoding=UTF-8 -classpath "C:\Users\Jackiechan\.m2\repository\org\junit\platform\junit-platform-launcher\1.3.1\junit-platform-launcher-1.3.1.jar;C:\Users\Jackiechan\.m2\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;C:\Users\Jackiechan\.m2\repository\org\junit\platform\junit-platform-engine\1.3.1\junit-platform-engine-1.3.1.jar;C:\Users\Jackiechan\.m2\repository\org\junit\platform\junit-platform-commons\1.3.1\junit-platform-commons-1.3.1.jar;C:\Users\Jackiechan\.m2\repository\org\opentest4j\opentest4j\1.1.1\opentest4j-1.1.1.jar;C:\Users\Jackiechan\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.3.1\junit-jupiter-engine-5.3.1.jar;C:\Users\Jackiechan\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.3.1\junit-jupiter-api-5.3.1.jar;D:\Program Files\JetBrains\IntelliJ IDEA 2022.3.2\lib\idea_rt.jar;D:\Program Files\JetBrains\IntelliJ IDEA 2022.3.2\plugins\junit\lib\junit5-rt.jar;D:\Program Files\JetBrains\IntelliJ IDEA 2022.3.2\plugins\junit\lib\junit-rt.jar;D:\javaprojects\backend-engineering\part01-spring\spring-aop-annotation\target\test-classes;D:\javaprojects\backend-engineering\part01-spring\spring-aop-annotation\target\classes;D:\repository\org\springframework\spring-context\6.0.6\spring-context-6.0.6.jar;D:\repository\org\springframework\spring-beans\6.0.6\spring-beans-6.0.6.jar;D:\repository\org\springframework\spring-core\6.0.6\spring-core-6.0.6.jar;D:\repository\org\springframework\spring-jcl\6.0.6\spring-jcl-6.0.6.jar;D:\repository\org\springframework\spring-expression\6.0.6\spring-expression-6.0.6.jar;D:\repository\org\junit\jupiter\junit-jupiter-api\5.3.1\junit-jupiter-api-5.3.1.jar;D:\repository\org\apiguardian\apiguardian-api\1.0.0\apiguardian-api-1.0.0.jar;D:\repository\org\opentest4j\opentest4j\1.1.1\opentest4j-1.1.1.jar;D:\repository\org\junit\platform\junit-platform-commons\1.3.1\junit-platform-commons-1.3.1.jar;D:\repository\org\springframework\spring-test\6.0.6\spring-test-6.0.6.jar;D:\repository\jakarta\annotation\jakarta.annotation-api\2.1.1\jakarta.annotation-api-2.1.1.jar;D:\repository\mysql\mysql-connector-java\8.0.25\mysql-connector-java-8.0.25.jar;D:\repository\com\google\protobuf\protobuf-java\3.11.4\protobuf-java-3.11.4.jar;D:\repository\com\alibaba\druid\1.2.8\druid-1.2.8.jar;D:\repository\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;D:\repository\org\springframework\spring-aop\6.0.6\spring-aop-6.0.6.jar;D:\repository\org\springframework\spring-aspects\6.0.6\spring-aspects-6.0.6.jar;D:\repository\org\aspectj\aspectjweaver\1.9.9.1\aspectjweaver-1.9.9.1.jar" com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.atguigu.test.AopTest,testCalculator
[AOP前置通知] 方法开始了
[AOP返回通知] 方法成功返回了
[AOP后置通知] 方法最终结束了
```

###### 3 为字段字段赋值功能

操作数据库更新或者插入操作时，如果插入的数据有更新时间、创建时间的字段时自动赋值

1声明一个注解

@AutoFill

* 在mapper层的方法添加该注解时，自动为时间相关的字段赋值

```java
package com.sky.annotation;

import com.sky.enumeration.OperationType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * 自定义注解 用于标识某个需要字段填充字段的方法
 * */
@Target(ElementType.METHOD)//指定只能加在方法上
@Retention(RetentionPolicy.RUNTIME)//运行时
public @interface AutoFill {
    //数据库操作类型 UPDATE,INSERT
    OperationType value();
}

```

2操作类型类

```java
ackage com.sky.enumeration;
/**
 * 数据库操作类型
 */
public enum OperationType {
    /**
     * 更新操作
     */
    UPDATE,
    /**
     * 插入操作
     */
    INSERT

}
```

3公共字段填充相关常量类

```java
package com.sky.constant;
/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant {
    /**
     * 实体类中的方法名称
     */
    public static final String SET_CREATE_TIME = "setCreateTime";
    public static final String SET_UPDATE_TIME = "setUpdateTime";
}
```

4实体类

```java
package com.sky.entity;

import java.time.LocalDateTime;

public class Food {
    private String foodName;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;

    public Food() {
    }

    public String getFoodName() {
        return foodName;
    }

    public void setFoodName(String foodName) {
        this.foodName = foodName;
    }

    public LocalDateTime getCreateTime() {
        return createTime;
    }

    public void setCreateTime(LocalDateTime createTime) {
        this.createTime = createTime;
    }

    public LocalDateTime getUpdateTime() {
        return updateTime;
    }

    public void setUpdateTime(LocalDateTime updateTime) {
        this.updateTime = updateTime;
    }
}

```

5切面类

```java
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Method;
import java.time.LocalDateTime;

/**
 * 自定义切面 实现公共字段填充处理逻辑
 * */
@Aspect
@Component
@Slf4j
public class AutoFillAspect {

    /**
     * 切入点
     * */
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")//mapper包下所有类的所有方法且被AutoFill注解标记
    public void autoFillPointCut(){}

    /**
     * 前置通知
     * */
    @Before(value = "autoFillPointCut()")
    public void autoFill(JoinPoint joinPoint)  {
        log.info("公共字段自动填充");
        //获取到当前被拦截的方法上的数据库操作类型
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获取方法上的注解对象
        OperationType operationType = autoFill.value();//获取AutoFill的值，获取数据库操作类型
        //获取到当前被拦截的方法的参数--实体对象
        Object[] args = joinPoint.getArgs();
        if (args==null || args.length==0){
            return;
        }
        Object entity = args[0];//获取第一个参数，约定实体类参数需要写在第一位
        //准备赋值的数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();
        //根据当前不同的操作类型，为对应的属性通过反射关系赋值
        //插入操作
        if (operationType == OperationType.INSERT){
            try {
                //通过反射获取方法
                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                //通过反射为对象属性赋值
                setCreateTime.invoke(entity,now);
                setUpdateTime.invoke(entity,now);
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else if (operationType == OperationType.UPDATE) {
            try {
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                setUpdateTime.invoke(entity,now);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

```

6mapper类

```java
@Mapper
public interface FoodMapper{
    //注意，需要使用实体类来传参，因为实体类中才有setCreateTime，setUpdateTime这两个方法名
    //插入新的食物
    @AutoFill(value = OperationType.INSERT)
    @Insert("insert into food (food_name,create_time,update_time) values (#{name},#{createTime}, #{updateTime})")
    void insertFood(Food food);
    //更新食物
    @AutoFill(value = OperationType.UPDATE)
    @Update("update food set (name=#{name},create_time=#{createTime},update_time=#{updateTime}) where id = #{id}")
    void updateFood(Food food)
}
```

##### 2.2.6相关方法

###### 2.2.6.1JoinPoint 

在 SpringAOP 中，`JoinPoint` 接口代表了一个程序执行的点，比如方法执行或异常处理。当使用 AOP 通知（Advice）时，你可以将 `JoinPoint` 作为参数传递到通知方法中，以便获取有关当前执行点的详细信息

* 用于所有类型的通知（`@Before`、`@After`、`@AfterReturning`、`@AfterThrowing`），但不包括环绕通知
* ProceedingJoinPoint是 `JoinPoint` 的子接口，专门用于环绕通知（`@Around`）

**JoinPoint 常用方法**

1.getArgs():返回一个对象数组，包含了被通知方法的参数

2.getThis():返回代理对象

3.getTarget():返回目标对象

4.getSignature():返回被通知方法的签名信息

5.toString():打印出正在执行的被通知方法的详细信息

6.toShort():提供正在执行的被通知方法的简短描述

7.toLongString():提供正在执行的被通知方法的完整描述

###### 2.2.6.2MethodSignature

```java
//通过JoinPoint获取
MethodSignature signature = (MethodSignature) joinPoint.getSignature();
//打印signature
//signature = String com.example.StartImpl.playBall
```

`MethodSignature()`: 构造函数，用于创建一个新的`MethodSignature`实例

Class getReturnType()：方法的返回值类型

* class java.lang.String

String[] getParameterNames()：获取参数名称

Class getDeclaringType()：获取类型，类的类型

* class com.example.StartImpl

String getDeclaringTypeName()：获取类型的名称

* com.example.StartImpl

Class[] getExceptionTypes()：获取异常类型

int getModifiers()：获取权限修饰符

**Method getMethod()：获取方法**

* public java.lang.String com.example



## 3、spring声明式事务

### 3.1声明式事务概念

#### 3.1.1编程式事务

编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在 Java 中，通常使用事务管理器(如 Spring 中的 `PlatformTransactionManager`)来实现编程式事务。

编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。

```java
Connection conn = ...;
  
try {
    // 开启事务：关闭事务的自动提交
    conn.setAutoCommit(false);
    // 核心操作
    // 业务代码
    // 提交事务
    conn.commit();
  
}catch(Exception e){
  
    // 回滚事务
    conn.rollBack();
  
}finally{
  
    // 释放数据库连接
    conn.close();
  
}
```

编程式的实现方式存在缺陷：

- 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。
- 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。

#### 3.1.2声明式事务

声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。

开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！

使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。

区别：

- 编程式事务需要手动编写代码来管理事务
- 而声明式事务可以通过配置文件或注解来控制事务。

#### 3.1.3spring事务管理器

##### 1.Spring声明式事务对应依赖

- spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）

##### 2.Spring声明式事务对应事务管理器接口

<img src="E:\课程资料\springboot\黑马springboot\图片\spring声明式事务接口·.png" style="zoom:150%;" />



### 3.1.4基于注解的声明式事务

```java
//启动类添加注解
@EnableTransactionManagement
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
```

需要被管理的事务

```java
//添加@Transactional注解
@Service
public class StudentImpl implements Student {
    @Autowired
    private StudentMapper studentMapper;
    @Override
    @Transactional
    public void changeInfo() {
        studentMapper.updateNoById(5,"100001");
        System.out.println("-----------");
        //int i = 1/0;
        studentMapper.updateNameById("如烟",5);
    }
}
```

##### 注解

###### @EnableTransactionManagement

* ElementType.*TYPE*
* 标注在启动类上，表示开启声明式注解

###### @Transactional

* ElementType.*TYPE*, ElementType.*METHOD*
* 当注解标注在类上时，表示该类的所有方法开启事务

属性:

* 1、 **value**:当在配置文件中有多个 TransactionManager，可以用该属性指定选择哪个事务管理器

* 2、 **propagation**:事务的传播行为

  * ```java
    @Transactional(propagation = Propagation.REQUIRED)
    ```

  * |           名称            |                             含义                             |
    | :-----------------------: | :----------------------------------------------------------: |
    |     REQUIRED (默认值)     |       如果父方法有事务，就加入，如果没有就新建自己独立       |
    |       REQUIRES_NEW        |        不管父方法是否有事务，我都新建事务，都是独立的        |
    |   Propagation.REQUIRED    |     如果当前存在事务，则加入当前事务，否则创建一个新事务     |
    | Propagation.REQUIRES_NEW  | 创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务 |
    |    Propagation.NESTED     | 如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样 |
    |   Propagation.SUPPORTS    |     如果当前存在事务，则加入该事务，否则以非事务方式执行     |
    | Propagation.NOT_SUPPORTED |        以非事务方式执行，如果当前存在事务，挂起该事务        |
    |   Propagation.MANDATORY   |           必须在一个已有的事务中执行，否则抛出异常           |
    |     Propagation.NEVER     |           必须在没有事务的情况下执行，否则抛出异常           |

    **注意**：在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果，**意思就是在这个类中调用这个类的方法，传播事务不会生效**

* 3、 **readyOnly**:该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读可写，默认值为false

* 4、**timeout**:该属性用于设置事务的超时秒数，默认值为-1表示永不超时

* 5、**isolation**:该属性用于设置底层数据库的事务隔离级别

  * ```java
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    ```

  * |       名称       |                    含义                     |
    | :--------------: | :-----------------------------------------: |
    | READ_UNCOMMITTED | 读取未提交数据(会出现脏读, 不可重复读,幻读) |
    |  READ_COMMITTED  |   读取已提交数据(会出现不可重复读和幻读)    |
    | REPEATABLE_READ  |            可重复读(会出现幻读)             |
    |   SERIALIZABLE   |                   串行化                    |

    A.读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用

    B.读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读

    C.可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题

    D.串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景

* 6、**rollbackFor**:设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚,**默认是 RuntimeException and Error 异常方可回滚**

  * ```java
    指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)
    指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, NullPointerException.class})
    ```

* 7、**rollbackForClassName**:设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚

  * ```java
    指定单一异常类名称：@Transactional(rollbackForClassName=“RuntimeException”)
    指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,“NullPointerException”})
    ```

* 8、**noRollbackFor**:设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚，与rollbackFor相反,**默认没有指定,如果指定,应该在rollbackFor的范围内**

* 9、**noRollbackForClassName**:设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚，与rollbackForClassName相反

## 4、全局异常处理

1. 声明异常处理控制器类

    异常处理控制类，统一定义异常处理handler方法！

```Java
/**
 * projectName: com.atguigu.execptionhandler
 * 
 * description: 全局异常处理器,内部可以定义异常处理Handler!
 */

/**
 * @RestControllerAdvice = @ControllerAdvice + @ResponseBody
 * @ControllerAdvice 代表当前类的异常处理controller! 
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

  
}
```
2. 声明异常处理hander方法

    异常处理handler方法和普通的handler方法参数接收和响应都一致！

    只不过异常处理handler方法要映射异常，发生对应的异常会调用！

    普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！

```Java
/**
 * 异常处理handler 
 * @ExceptionHandler(HttpMessageNotReadableException.class) 
 * 该注解标记异常处理Handler,并且指定发生异常调用该方法!
 * 
 * 
 * @param e 获取异常对象!
 * @return 返回handler处理结果!
 */
@ExceptionHandler(HttpMessageNotReadableException.class)
public Object handlerJsonDateException(HttpMessageNotReadableException e){
    
    return null;
}

/**
 * 当发生空指针异常会触发此方法!
 * @param e
 * @return
 */
@ExceptionHandler(NullPointerException.class)
public Object handlerNullException(NullPointerException e){

    return null;
}

/**
 * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! 
 * 具体异常处理Handler优先级更高!
 * 例如: 发生NullPointerException异常!
 *       会触发handlerNullException方法,不会触发handlerException方法!
 * @param e
 * @return
 */
@ExceptionHandler(Exception.class)
public Object handlerException(Exception e){

    return null;
}
```
3. 配置文件扫描控制器类配置

    确保异常处理控制类被扫描

```Java
 <!-- 扫描controller对应的包,将handler加入到ioc-->
 @ComponentScan(basePackages = {"com.atguigu.controller",
 "com.atguigu.exceptionhandler"})
```

## 5、MVC配置

### 5.1WebMvcConfigurationSupport、WebMvcConfigurer 、WebMvcConfigurationAdapter的关系和区别

* 关系：WebMvcConfigurerAdapter、WebMvcConfigurer和WebMvcConfigurationSupport是SpringMVC框架中用于配置Web应用程序的类。WebMvcConfigurerAdapter是WebMvcConfigurer的过时实现类，WebMvcConfigurationSupport是WebMvcConfigurer的抽象实现类

* WebMvcConfigurerAdapter：是一个已过时的类，它实现了WebMvcConfigurer接口，并提供了一些默认的实现方法。在Spring 5.0版本之后，推荐直接实现WebMvcConfigurer接口而不是继承WebMvcConfigurerAdapter

* WebMvcConfigurer：是一个接口，用于配置Spring MVC的行为。提供了一系列的回调方法，可以在进行自定义配置，例如添加拦截器、配置视图解析器、配置消息转换器等,**只需要对部分配置进行自定义时，应该使用WebMvcConfigurer**

* WebMvcConfigurationSupport：是一个抽象类，实现了WebMvcConfigurer接口，并提供了一些默认的配置。如果需要更深入地定制Spring MVC的行为，可以继承该类并重写相应的方法。可以自定义一些配置，比如添加拦截器、过滤器等。在这个类中，可以通过重写addInterceptors()方法来添加拦截器，通过重写addCorsMappings()方法来配置跨域请求，通过重写addResourceHandlers()方法来配置静态资源的访问路径等,**如果我们需要对Spring MVC的配置进行大量的自定义**，可以选择继承该类并重写其中的方法。但是需要注意的是，**继承该类会覆盖Spring MVC的部分默认配置,只要有实体类继承了这个接口，那么spring MVC的自动配置都会失效**

**`@EnableWebMvc`注解用于启用Spring MVC的功能，它会自动配置一些默认的行为，例如视图解析器、资源映射等。如果你在配置类中添加了`@EnableWebMvc`注解，那么Spring将会完全接管Spring MVC的配置，包括跨域配置，而不再使用默认的配置，大部分情况下不需要添加,@EnableWebMvc=WebMvcConfigurationSupport**

WebMvcConfigurer和WebMvcConfigurationSupport的区别

![](E:\课程资料\springboot\黑马springboot\图片\WebMvcConfigurer和WebMvcConfigurationSupport的区别.png)

**总结：**

* 一般情况下实现WebMvcConfigurer就够了，除非自己定义所有配置
* @EnableWebMvc + WebMvcConfigurer = WebMvcConfigurationSupport
* @EnableWebMvc=WebMvcConfigurationSupport
* 如果有配置类继承了WebMvcConfigurationSupport，那么webmvc的自动配置类WebMvcAutoConfiguration就会失效

### 5.2配置

#### 5.2.1拦截器

##### **1拦截逻辑**

```java
//在Spring MVC中，拦截器是一种用于拦截请求并在处理请求之前或之后执行特定操作的组件。拦截器可以用于实现日志记录、权限验证、参数校验等功能
@Component
public class MyInterceptor implements HandlerInterceptor {
 
    //preHandle：在处理请求之前被调用，可以进行一些前置处理操作。如果该方法返回false，则请求将被终止，后续的拦截器和处理器将不会被执行。
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
		System.out.println("MyInterceptor preHandle");
		return true;
	}
 
    //在处理请求之后、渲染视图之前被调用，可以进行一些后置处理操作。可以通过该方法修改ModelAndView对象
	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
		System.out.println("MyInterceptor postHandle");
	}
 
    //在整个请求完成之后被调用，可以进行一些资源清理操作
	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
		System.out.println("MyInterceptor afterCompletion");
	}
}

```

HandlerInterceptor接口方法详解：
①preHandler
在请求处理之前被调用。该方法在Interceptor类中最先执行，用来进行一些前置初始化操作或是对当前请求做预处理，也可以进行一些判断来决定请求是否要继续进行下去。该方法的返回值是Boolean类型，当它返回false时，表示请求结束，后续的Interceptor和Controller都不会再执行；当它返回为true时会继续调用下一个Interceptor的preHandle方法，如果已经是最后一个Interceptor的时候就会调用当前请求的Controller方法。
②postHandler
在请求处理完成之后调用。也就是Controller方法调用之后执行，但是它会在DispatcherServlet进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller处理之后的ModelAndView对象进行操作。
③afterCompletion
在整个请求结束后调用。就是对应的Interceptor类的postHandler方法返回true时才执行。就是说该方法将在整个请求结束之后，
也就是在DispatcherServlet渲染了对应的视图之后执行。此方法主要用来进行资源清理。
注：官方其实不建议我们非要把3个方法都重写，我们只要对需要的方法重写接口，就比如大部分项目只需要重写preHandler方法

##### 2**注册拦截器**

###### 2.1通过实现WebMvcConfigurer实现

```java
@EnableWebMvc
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private MyInterceptor myInterceptor;
	//WebMvcConfigurer是接口，方法已经写好参数，只能使用InterceptorRegistry
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(myInterceptor)
        	.addPathPatterns("/**")
            .excludePathPatterns("/static/**");;
    }
   
}

```

###### 2.2通过继承WebMvcConfigurationSupport实现

```java
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {

    @Autowired
    private MyInterceptor myInterceptor;

   //方法一
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(myInterceptor)
        	.addPathPatterns("/**")
            .excludePathPatterns("/static/**");;
    }
    //方法二
    @Override
    protected void addInterceptors(InterceptorRegistration registration){
        registration.order(1)
                .addPathPatterns("/**")
                .excludePathPatterns("/user/login");
    }
   
}
```

下面不再演示WebMvcConfigurationSupport的方式

拦截器中常用的类

InterceptorRegistry类方法介绍：
①addInterceptor
该方法用于向拦截器链中添加一个拦截器。interceptor参数为待添加的拦截器对象，可以是自定义的拦截器类或Spring提供的预置拦截器。返回值为InterceptorRegistration对象，用于进一步配置该拦截器的属性。
②addWebRequestInterceptor
该方法用于向WebRequest拦截器链中添加一个拦截器。interceptor参数为待添加的拦截器对象，可以是自定义的WebRequestInterceptor类或者Spring提供的预置拦截器。也是返回值为InterceptorRegistration对象，用于进一步配置该拦截器的属性。
③getInterceptors
用于获取当前已经添加到拦截器链中的所有拦截器，返回值为List<HandlerInterceptor>对象，表示拦截器列表

InterceptorRegistration类方法介绍：
①order
该方法用于设置拦截器的执行顺序，即在拦截器链中的位置。order参数为一个整数，值越小表示越先执行。
②addPathPatterns
该方法用于设置需要拦截的请求路径模式，即满足哪些请求路径时才会触发该拦截器。若`"/**"`则拦截全部；传入的参数是一个字符串数组，包含多个Ant风格的路径模式，例如`"/api/**"`、`"/user/*"`等。
③excludePathPatterns
该方法用于设置不需要拦截的请求路径模式，即满足哪些请求路径时不会触发该拦截器。一般不拦截，如登录或者Swagger等传入的参数是一个字符串数组，包含多个Ant风格的路径模式，例如 `"/api/login"`、`"/user/login"`等。
④pathMatcher
该方法用于设置该拦截器所使用的PathMatcher实例，从而可以自定义路径匹配逻辑

小拓展

```java
public class MyInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 在请求处理之前执行的逻辑
        System.out.println("请求的URL：" + request.getRequestURL());
        System.out.println("请求的参数：" + request.getParameterMap());
        System.out.println("处理器的类名：" + handler.getClass().getName());
        return true; // 返回 true 表示继续执行后续的拦截器和处理器，返回 false 表示终止请求的处理
    }
    
	Object handler参数表示当前请求所要调用的处理器（即Controller类或方法）。handler参数的类型可以有以下几种：
	
	1. HandlerMethod：表示当前请求要调用的Controller方法。HandlerMethod是Spring MVC框架中的一个类，用于封装Controller类和方法的相关信息，如类名、方法名、参数等。
	 
		HandlerMethod类是Spring框架中的一个类，用于表示处理请求的方法。它包含了一些常用的方法，如下所示：
		
		1. `getMethod()`: 获取处理请求的方法对象。
		
		2. `getBean()`: 获取处理请求的方法所属的对象。
		
		3. `getBeanType()`: 获取处理请求的方法所属的对象的类型。
		
		4. `getReturnType()`: 获取处理请求的方法的返回类型。
		
		5. `getMethodParameters()`: 获取处理请求的方法的参数列表。
		
		6. `getMethodAnnotation(Class<T> annotationType)`: 获取处理请求的方法上指定类型的注解。
		
		7. `getMethodAnnotations()`: 获取处理请求的方法上的所有注解。
		
		8. `getMethodParameterAnnotations()`: 获取处理请求的方法的参数上的所有注解。
		
		9. `getMethodParameters()`: 获取处理请求的方法的参数列表。
		
		10. `getMethodParameterNames()`: 获取处理请求的方法的参数名称列表。
	2. ResourceHttpRequestHandler：表示当前请求要调用的静态资源处理器。ResourceHttpRequestHandler是Spring MVC框架中的一个类，用于处理静态资源请求，如图片、CSS、JavaScript等。
		ResourceHttpRequestHandler是Spring MVC框架中用于处理静态资源的处理器类，常用的方法包括：
		
		1. setLocations(Resource... locations)：设置静态资源的位置，可以传入多个Resource对象。
		
		2. setCacheSeconds(int cacheSeconds)：设置静态资源的缓存时间，单位为秒。
		
		3. setUseLastModified(boolean useLastModified)：设置是否使用最后修改时间来判断是否需要重新加载静态资源。
		
		4. setServletContext(ServletContext servletContext)：设置ServletContext对象，用于获取静态资源的真实路径。
		
		5. handleRequest(HttpServletRequest request, HttpServletResponse response)：处理静态资源请求，将静态资源输出到响应流中。
		
		6. getResource(HttpServletRequest request)：获取请求对应的静态资源，返回Resource对象。
		
		7. getLastModified(HttpServletRequest request)：获取请求对应的静态资源的最后修改时间，返回long类型的时间戳。
		
		8. isResourceNotModified(HttpServletRequest request, HttpServletResponse response, Resource resource)：判断请求对应的静态资源是否需要重新加载，如果需要重新加载则返回false，否则返回true。
		
		9. getResourceUrl(Resource resource, HttpServletRequest request)：获取静态资源的URL地址，返回String类型的URL地址。
		
		10. getResourcePaths(String path)：获取指定路径下的所有静态资源路径，返回Set<String>类型的路径集合。
	3. DefaultServletHttpRequestHandler：表示当前请求要调用的默认Servlet处理器。DefaultServletHttpRequestHandler是Spring MVC框架中的一个类，用于处理默认Servlet请求，如处理静态资源的默认Servlet。
	
		DefaultServletHttpRequestHandler是Spring MVC框架中的一个类，用于处理静态资源的请求。它继承自HttpRequestHandlerAdapter类，并实现了HttpRequestHandler接口。下面是DefaultServletHttpRequestHandler类中常用的方法：
		
		1. handleRequest(HttpServletRequest request, HttpServletResponse response)：处理HTTP请求并生成响应。这是HttpRequestHandler接口中定义的方法，用于处理具体的请求。
		
		2. setServletContext(ServletContext servletContext)：设置ServletContext对象。这个方法用于设置Servlet上下文，以便在处理请求时可以访问ServletContext中的资源。
		
		3. setDefaultServletName(String defaultServletName)：设置默认的Servlet名称。当请求的资源无法匹配到其他处理器时，会使用默认的Servlet来处理请求。
		
		4. setCacheSeconds(int cacheSeconds)：设置缓存时间。这个方法用于设置静态资源的缓存时间，以便浏览器可以缓存资源并减少请求次数。
		
		5. setAlwaysUseFullPath(boolean alwaysUseFullPath)：设置是否始终使用完整的路径。默认情况下，DefaultServletHttpRequestHandler会根据请求的相对路径来查找资源，如果设置为true，则始终使用完整的路径。
		
		这些是DefaultServletHttpRequestHandler类中常用的方法，通过调用这些方法可以对静态资源的处理进行配置和定制。
	
	根据不同的请求类型和配置，handler参数可能是上述三种类型之一。在preHandle方法中，可以通过判断handler参数的类型，来进行相应的处理逻辑。

    // 其他方法省略...
}

```

#### 5.2.2跨域

方法一：**使用注解 @CrossOrigin**

方法二：配置

只演示通过实现WebMvcConfigurer实现跨域的代码

```java
//添加允许跨域的路径
//WebMvcConfigurer是接口，已经写好了方法，所以只能使用CorsRegistry类，如何需要使用CorsRegistration只能继承WebMvcConfigurationSupport
@Configuration
public class WebMvcConfiguration implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/user/login");
        registry.addMapping("/user/register");
    }
}


```



**CorsRegistry类方法介绍：**

①addMapping
该方法用于添加允许跨域访问的路径，String类型，若存在多个路径则需要在CorsRegistry里配置多个

**CorsRegistration类方法介绍：**

CorsRegistration是CorsRegistry的辅助类，使用它可以对单个跨域请求进行更细粒度的配置。
①allowedOrigins（低版本使用，但是现在高版本也支持）
设置允许跨域请求的来源URL。该方法接受多个参数，每个参数为一个允许的来源URL。或者设置"*"
②allowedOriginPatterns（一般使用这种方式）
设置允许跨域请求的来源URL的模式。该方法接受多个参数，每个参数为一个允许的来源URL模式。或者设置"*"
③allowCredentials
设置是否允许跨域请求携带凭证信息。默认情况下，浏览器不会向跨域请求发送Cookie等凭证信息。如果希望携带凭证信息，则需要将allowCredentials方法设置为true。
④allowedMethods
设置允许跨域请求的HTTP方法。该方法接受多个参数，每个参数为一种允许的HTTP请求方式。
⑤allowedHeaders
设置允许请求携带的HTTP头信息。该方法接受多个参数，每个参数为一种允许的HTTP头信息。(放行哪些请求头部信息)
⑥exposedHeaders
设置响应头信息，这些信息允许客户端访问。该方法接受多个参数，每个参数为一种允许的响应头信息。(暴露哪些响应头信息)
⑦combine
将当前CorsRegistration对象与另一个CorsConfiguration对象合并，返回合并后的CorsConfiguration对象。可以使用该方法将多个CorsRegistration对象的配置合并到同一个CorsConfiguration对象中。
⑧maxAge
设置响应的缓存时间，单位为秒，默认30分钟。
例如，当设置maxAge为3600时，如果浏览器在一小时内再次向同一个目标URL发送跨域请求，就可以直接使用以前的预检请求结果，而不需要再次进行预检请求。maxAge属性只影响预检请求的缓存时间，而不会影响正常的跨域请求，因此不会对实际的业务逻辑产生影响。此外，maxAge属性的具体值需要根据实际情况进行调整，过小的缓存时间可能会导致频繁的预检请求，过大的缓存时间可能会使跨域请求的控制权得不到及时更新，从而增加安全风险

#### 5.2.3注册页面跳转

```java
@Configuration
public class WebMvcConfiguration implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //设置视图控制器级别
        registry.setOrder(1);
        // 跳转方式为：转发; 第一个参数为访问路径, 第二个参数为返回的视图路径名称 localhost:8080/login跳转到hello.html页面
        //注意：视图需要在静态资源目录下
        registry.addViewController("/login").setViewName("/hello.html");
        //重定向
        //参数一 原来的访问路径 参数二 重定向的页面路径，需要添加后缀
        registry.addRedirectViewController("/exit","/login.html");
    }
}
```

**ViewControllerRegistry类说明：**
①addViewController(String urlPath)
通过urlPath参数指定的请求URL路径（例如"/home"）注册一个简单的视图控制器，该方法返回一个ViewControllerRegistration对象，通过该对象可以设置相关属性，如视图名称、请求方式等。如：registry.addViewController(“/login”);
②setOrder(int order)
设置当前视图控制器的执行顺序，当有多个视图控制器针对同一请求路径时，可以使用该方法进行优先级排序。默认情况下，不同的视图控制器按照它们被注册的顺序执行。
③addRedirectViewController(String urlPath, String redirectUrl)
注册一个重定向视图控制器，将urlPath请求路径重定向到指定的重定向地址redirectUrl。
如：registry.addRedirectViewController(“/toBaidu”,“https://www.baidu.com”)

**ViewControllerRegistration类说明：**
①setViewName(String viewName)
资源路径的前缀
②setStatusCode(HttpStatus statusCode)
配置访问不存在资源的响应码，如下常见的：
HttpStatus.BAD_REQUEST：请求参数错误或格式不正确，例如缺少必需参数、参数类型错误等。
HttpStatus.UNAUTHORIZED：未经授权访问，需要用户登录或提供凭证。
HttpStatus.FORBIDDEN：已经授权但访问被禁止，通常意味着权限不足或需要进行进一步身份验证。
HttpStatus.NOT_FOUND：请求的资源不存在，通常使用自定义的404错误页面进行提示。
HttpStatus.METHOD_NOT_ALLOWED：请求方式不支持，例如GET请求访问只支持POST的接口时会返回405错误。
HttpStatus.INTERNAL_SERVER_ERROR：服务器内部错误，需要在后台进行排查和修复。
示例：registry.addViewController(“/**”).setStatusCode(HttpStatus.NOT_FOUND);
说明：访问不存在的页面我一律按照404处理，但是我们templates/error/404.html页面需要存在

注：按照之前配置的thymeleaf配置来说，默认根路径为resources/templates，跳转的资源文件都是.html文件

#### 5.2.4静态资源处理

默认的静态资源访问目录

```java
"classpath:/META-INF/resources/",
"classpath:/resources/", 
"classpath:/static/", 
"classpath:/public/"
```

访问方式:当前项目根路径/ + 静态资源名  localhost:8080/photoName.png

原理： 静态映射/**

请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面

##### 1 yaml配置

```yaml
spring:
  mvc:
    static-path-pattern: "res/**" #访问路径,修改后欢迎页和Favicon.ico失效
  web:
    resources:
      static-locations: [classpath:/photo/] #静态资源路径
      add-mappings: true #开启静态资源访问，false为禁止，禁止后所有的静态资源都不能访问
 # 如何访问 http://localhost:8080/res/p.png    
```

##### 2 配置类

```java
@Configuration
public class WebMvcConfiguration implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("classpath:/public","classpath:/photo");
    }
}

```

**ResourceHandlerRegistry类方法介绍：**

①addResourceHandler
该方法用于指定静态资源的URL路径，支持Ant风格的通配符，如`"/resources/**"`表示匹配所有以"/resources/"开头的请求

**ResourceHandlerRegistration类方法介绍：**
①addResourceLocations
该方法为静态资源所在的物理路径或URL。可以使用多个addResourceLocations方法指定多个路径，如下例：

```java
//请求匹配到 /resources/** 的 URL 时，会去 classpath:/static/", "file:/opt/files/ 目录下查找对应的静态资源文件
registry.addResourceHandler("/resources/**")
	.addResourceLocations("classpath:/static/", "file:/opt/files/")
```

说明：
classpath:/static/表示在项目的Classpath下（即src/main/resources文件夹下）查找static文件夹，file:/opt/files/表示在系统中的/opt/files/目录下查找文件。

②setCacheControl
此方法用于设置缓存控制头（cache-control header），CacheControl是一个封装了缓存策略的类。例如：

```java
CacheControl cc = CacheControl.maxAge(30, TimeUnit.DAYS).cachePublic();
registry.addResourceHandler("/resources/**").addResourceLocations("classpath:/static/")
	.setCacheControl(cc);
```

说明：这将指示浏览器缓存静态资源30天，并且它们是public缓存，意味着中间代理服务器也可以缓存资源。
③setCachePeriod
该方法用于设置静态资源缓存时间，参数类型为Duration类型。如：

```java
registry.addResourceHandler("/resources/**").addResourceLocations("classpath:/static/")
	.setCachePeriod(Duration.ofMinutes(5));
```

说明：静态资源缓存的过期时间为5分钟
④setOptimizeLocations
此方法用于启用或禁用位置优化。如果启用位置优化，则将优化静态资源的位置，以便并发访问静态资源时可以获得更好的性能。默认情况下，位置优化是禁用的。
⑤setUseLastModified
此方法用于启用或禁用上次修改时间检查（last-modified check）。如果启用上次修改时间检查，则在每个请求中发送一个if-modified-since头，以检查是否需要返回新内容。默认情况下，上次修改时间检查是启用的。
⑥resourceChain
用于开启或关闭ResourceChain模式。当开启ResourceChain模式时，每个资源文件都会自动添加版本号，避免浏览器缓存问题。
例如：

```java
registry.addResourceHandler("/resources/**").addResourceLocations("classpath:/static/")
	.resourceChain(true);
```

注意，要使ResourceChain生效，还需要设置addResolver如：

```java
.resourceChain(false)
	// 添加VersionResourceResolver，且指定版本号
	.addResolver(new VersionResourceResolver()
	.addFixedVersionStrategy("1.0.0", "/**")); // 下次访问地址：http://localhost:8881/resources/1.0.0/xxx.css
```

#### 5.2.4WebMvcConfigurationSupport常用方法

```java
/** 解决跨域问题 **/
void addCorsMappings(CorsRegistry registry) ;
   /** 添加拦截器 **/
void addInterceptors(InterceptorRegistry registry);
  /** 视图跳转控制器 **/
void addViewControllers(ViewControllerRegistry registry);
/** 这里配置视图解析器 **/
void configureViewResolvers(ViewResolverRegistry registry);
 /** 配置内容裁决的一些选项 **/
void configureContentNegotiation(
       ContentNegotiationConfigurer configurer);
  /** 静态资源处理 避免静态资源被拦截**/
void addResourceHandlers(
       ResourceHandlerRegistry registry);
    /** 默认静态资源处理器 **/
void configureDefaultServletHandling(
    DefaultServletHandlerConfigurer configurer);

```

细讲两个

**配置视图解析器:**

```java
//设置了 JSP 视图解析器的前缀和后缀，分别为 "/WEB-INF/views/" 和 ".jsp"。这意味着 Spring MVC 应用程序在渲染视图时，会在 "/WEB-INF/views/" 目录下查找以 ".jsp" 为后缀的 JSP 文件
@Configuration
public class WebConfig extends WebMvcConfigurationSupport {
    @Override
    protected void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/WEB-INF/views/", ".jsp");
    }
}
```

**配置内容裁决：**

```java
@Configuration
public class WebConfig extends WebMvcConfigurationSupport {
    @Override
    protected void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        //设置默认的内容类型为 application/json，即如果客户端没有指定期望的内容类型，则返回 JSON 格式的数据
        configurer.defaultContentType(MediaType.APPLICATION_JSON)
            //配置了当请求的 Accept 头中包含 application/json 或 json 时，返回 JSON 格式的数据
                .mediaType("json", MediaType.APPLICATION_JSON)
            //配置了当请求的 Accept 头中包含 application/xml 或 xml 时，返回 XML 格式的数据
                .mediaType("xml", MediaType.APPLICATION_XML);
    }
}
```



#### 5.2.nWebMvcConfigurer其他技巧

##### 中文乱码，时间格式等处理

```java
package com.syh.pdd.config.web;
 
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.servlet.config.annotation.*;
 
import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
 
@Configuration
public class WebConfig implements WebMvcConfigurer {
 
    // 用户头像
    @Value("${file.userImage.writePath}")
    private String userImageWritePath;
    @Value("${file.userImage.readPath}")
    private String userImageReadPath;
 
    /**静态资源处理
     * 映射文件路径配置
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
 
 
        registry.addResourceHandler("/webjars/**")
                .addResourceLocations("classpath:/META-INF/resources/webjars/");
 
        registry.addResourceHandler("BJTPReadpath")
                .addResourceLocations("file:"+ "BJTPSavepath");
 
        // 浏览器测试图片回显路径: http://IP:8080/file/ewm/Img/2023/10/12/图片名称.jpg
  	    registry
                // 图片回显路径
                .addResourceHandler("file/ewm/Img/**")
                // 图片存放路径
                .addResourceLocations("file:D:/file/ewm/Img/");
        }
    }
 
    /**
     * 跨域配置添加
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 设置允许跨域的路径
        registry.addMapping("/**")
                // 设置允许跨域请求的域名
              //  .allowedOrigins("*")
                .allowedOriginPatterns("*")
                // 是否允许证书 不再默认开启
                .allowCredentials(true)
                // 设置允许的方法
                .allowedMethods("*")
                // 跨域允许时间
                .maxAge(3600);
    }
 
    //解决中文乱码问题
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        //解决中文乱码
        converters.add(responseBodyConverter());
        //解决 添加解决中文乱码后 上述配置之后，返回json数据直接报错 500：no convertter for return value of type
        converters.add(messageConverter());
    }
    @Bean
    public HttpMessageConverter<String> responseBodyConverter(){
        StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName("UTF-8"));
        return converter;
    }
    @Bean
    public MappingJackson2HttpMessageConverter messageConverter() {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        converter.setObjectMapper(getObjectMapper());
        return converter;
    }
    @Bean
    public ObjectMapper getObjectMapper() {
        return new ObjectMapper();
    }
 
    /**
     *  格式化返回的内容
     *  https://my.oschina.net/u/3681868/blog/3075150
     * */
    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        ObjectMapper objectMapper = converter.getObjectMapper();
        // 时间格式化
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
        // 设置格式化内容
        converter.setObjectMapper(objectMapper); 
        
        //将自己的消息转化器加入容器中
        //把索引位置设置为0，优先使用
        converters.add(0, converter);
    }
 
    /**
     * 添加Web项目的拦截器
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //放行路径
        List<String> jwtExcludePatterns = new ArrayList();
        // 登录接口放行
        jwtExcludePatterns.add("/api/user/login");
        // 验证码放行
        jwtExcludePatterns.add("/api/user/getVerify/**");
        // 前端更换头像请求，没有走拦截器，此处放行
        jwtExcludePatterns.add("/api/user/updatePicture");
        // 对所有api开头的访问路径，都通过MyInterceptor拦截器进行拦截，MyInterceptor代码在下面
        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/api/**")
                .excludePathPatterns(jwtExcludePatterns);
    }
 
    /*解析器  使用方法在文章末尾*/
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        WebMvcConfigurer.super.addArgumentResolvers(resolvers);
    }
}

```



# 三.原理



# 四.其他技术

## 1、JWT

### JWT简介

## 2、Swagger

### 2.1导入依赖

```xml
        <!--导入swagger依赖-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
        <!--swagger ui-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
```

使用第三方ui

```xml
<!--如果你不习惯swagger原生态页面,可以使用拓展-->
 <!--第一种-->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>swagger-bootstrap-ui</artifactId>
            <version>1.9.6</version>
        </dependency>

 <!--第二种,很推荐 @EnableKnife4-->
<dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-spring-boot-starter</artifactId>
            <!--<version>3.0.2</version>-->
            <version>2.0.9</version>
            <exclusions>
                <exclusion>
                    <artifactId>springfox-swagger2</artifactId>
                    <groupId>io.springfox</groupId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <artifactId>springfox-swagger2</artifactId>
            <groupId>io.springfox</groupId>
            <version>2.10.0</version>
        </dependency>

    </dependencies>
 <!--第二种需要在yml中配置才能开启增强
knife4j:
  enable: true
@ApiSupport(author = "作者名称")-->
```

### 2.2配置Swagger

```java
@EnableSwagger2WebMvc//新版的注解，旧的是@EnableSwagger2
@EnableKnife4j//使用knife4j时推荐该注解
@Configuration
public class SwaggerConfig {
 
 
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
                //是否开启,如果设置false,则无法访问swagger
                .enable(true)
                .select()
                //扫描的路径包,设置basePackage会将包下的所有被@Api标记类的所有方法作为api
                .apis(RequestHandlerSelectors.basePackage("com.itruyan.controller"))
                //指定路径处理,PathSelectors.any()代表所有的路径
                .paths(PathSelectors.any())
                .build();
    }
 
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                //设置swagger文档标题
                .title("spring-boot-demo-swagger")
                //文档描述
                .description("这是一个简单的 Swagger API 演示")
                //联系人信息,name:联系人姓名  url:联系人访问连接
                .contact(new Contact("联系人", "localhost", "email"))
                .version("1.0.0-SNAPSHOT")
                .build();
    }
}
```

### 2.3常用注解

```
@Api(tags = "类描述")：该注解一般作用在controller层，用来描述该类是处理什么请求
@ApiOperation("方法描述")：该注解作用在方法上，用来描述方法的作用
@ApiParam("参数")：该注解作用在请求参数上，用来描述参数
@ApiImplicitParams({
        @ApiImplicitParam(name = "id", value = "用户编号", dataType = DataType.INT, paramType = ParamType.PATH)
})： 这个注解也是用来描述方法，不同的是，该注解常常用来批量描述
```

### 2.4访问地址

原生ui界面访问地址：http://ip:port/swagger-ui.html  

第三方ui界面访问地址： http://ip:port/doc.html     localhost:9090/doc.html

### 2.5访问资源处理

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
 
 
    //出现404有可能是因为springboot版本过高
    //这里是配置第三方的ui
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
    }
}
//出现其他问题时配置
		// 解决静态资源无法访问
        registry.addResourceHandler("/**").addResourceLocations("classpath:/static/");
        // 解决swagger无法访问
        registry.addResourceHandler("swagger-ui.html")
                .addResourceLocations("classpath:/META-INF/resources/");
        // 解决swagger的js文件无法访问
        registry.addResourceHandler("/webjars/**")
                .addResourceLocations("classpath:/META-INF/resources/webjars/");
```



## 3、Json格式转换

# 五.项目管理

## 1、Git

![](E:\课程资料\springboot\黑马springboot\图片\git流程.png)

```javascript
本地仓库：是在开发人员自己电脑上的Git仓库,存放我们的代码(.git 隐藏文件夹就是我们的本地仓库)     
远程仓库：是在远程服务器上的Git仓库,存放代码(可以是github.com或者gitee.com 上的仓库,或者自己该公司的服务器)
工作区: 我们自己写代码(文档)的地方
暂存区: 在 本地仓库中的一个特殊的文件(index) 叫做暂存区,临时存储我们即将要提交的文件
------------
Clone：克隆，就是将远程仓库复制到本地仓库
Push：推送，就是将本地仓库代码上传到远程仓库
Pull：拉取，就是将远程仓库代码下载到本地仓库,并将代码 克隆到本地工作区
```

![](E:\课程资料\springboot\黑马springboot\图片\git流程_详解.png)

### 1.1配置git环境

git config --global

* 用户名配置

* ```
  git config --global user.name "你的用户名"
  ```

* 邮箱配置

* ```
  git config --global user.email "你的邮箱"
  ```

### 1.2本地仓库操作

#### 1.2.1创建本地仓库git init

新建一个文件夹，右键->Git Base Here->输入命令git init

文件夹内有一个 .git文件夹，至此本地仓库初始化完成

#### 1.2.2创建文件 touch

touch 文件名

#### 1.2.3添加到本地仓库git add git commit

* 添加到缓存

  * git add 文件名

  * git add .  |  git add --all把所有文件添加到缓存,注意只包括改动的文件，不改动的不会放到缓存区

  * 注意：

    *  git add --all这个命令还会把删除的文件的记录也提交进去

      如你在本地删除了min.c 这个命令会把删除信息也记录进去，然后在提交的时候把仓库里对应的min.c也删除掉，也就是说你在本地做的删除操作会被记录，提交仓库时会删除同样的文件，如果不想删除文件，可以使用git add .，注意后面有一个“.”点的符号，这个命令跟git add --all一样，但是不会记录删除操作

* 提交到本地仓库

  * git commit -m "描述提交的信息"
  * 该命令回将缓存的所有文件提交到本地仓库，可以使用git status查看添加到缓存但未提交到本地仓库的文件 

* 改写最近一次提交的描述

  * git commit --amend:
  * 输入命令后进入编辑器界面，和linux操作文件一样

* 查看历史提交日志

  * git log 完整输出
  * git log --pretty=oneline 简洁输出

#### 1.2.4回滚仓库代码git reset

![](E:\课程资料\springboot\黑马springboot\图片\git-log信息.png)

1查看历史版本

* 第一行那一长串c47cdffb9a2ecbd01ba6669d19d886e78959e6d5就是id

2回滚

2.1回滚到指定历史版本

* git reset --[soft | mixed | hard] id
  * 使用`--soft`就仅仅将头指针恢复，已经add的暂存区以及工作空间的所有东西都不变
  * 如果使用`--mixed`，就将头恢复掉，已经add的暂存区也会丢失掉，工作空间的代码什么的是不变的
  * 如果使用`--hard`，那么一切就全都恢复了，头变，aad的暂存区消失，代码什么的也恢复到以前状态

例 git reset --hard c47cdffb9a2ecbd01ba6669d19d886e78959e6d5

2.2回滚到当前仓库指向的版本

* 回滚到上一次提交的版本, 例如上图是 HEAD -> master
  * git reset --hard HEAD^
  * ^代表上一个版本的意思，HEAD代表当前仓库的指向，当前HEAD指向master，就代表回滚到master上一次提交的版本
* 回滚到当前仓库的指定版本
  * git reset --hard HEAD~3
  * 后面的~3，代表以当前版本为基数，回滚多少次。HEAD~3代表回滚master前三个版本\

#### 1.2.5查看当前仓库状态git status

* git status

![](E:\课程资料\springboot\黑马springboot\图片\git-status.png)

```json
工作目录下的状态！！工作目录下的状态！！！
1 untracked 未跟踪（未被纳入版本控制,还没有添加到缓存） 
2 tracked 已跟踪（被纳入版本控制）     
    2.1 Staged 已暂存状态(已经添加到缓存)            
    2.2 Unmodified 未修改状态       
    2.3 Modified 已修改状态(已经提交了，但又修改了又没提交)          
```

### 1.3单个文件操作

#### 1将文件撤销回到最近一次修改的状态git checkout

* git checkout -- 文件名  [注意：--两边都有空格]

#### 2查看单个文件可回滚版本git log

* git log 文件名

#### 3删除文件git rm

* git rm 文件名
  * 会删除工作区和仓库的文件，文件必须是已经commit,如果文件在缓存区则无法删除

* rm 文件名
  * 只会删除工作区的文件，git会提示文件被删除，重新提交就可以了 git add . ->git commit -m"delete file"

### 1.4查看提交历史git reflog

* git reflog

### 1.5使用git rm后恢复文件

* 前提：文件已经提交，且使用的是git rm命令，rm命令删除的不可以   git rm a.txt
* 1 在使用git reset重置所有缓存区操作                                                   git reset
* 2 重置完成之后在使用git checkout命令将文件取消操作                       git checkout a.txt

### 1.6分支

#### 1.6.1创建分支git branch、git checkout

* git branch 

  * 然后我们在使用branch来查看当前属于哪个分支，也就是查看HEAD的指向
  * 如果后面跟着名字则会创建分支，但不会切换

* git checkout -b 分支名称

  * 创建完成分支后会自动切换过去

  * 相当于

    ```javascript
    git branch 分支名称
    git checkout 分支名称
    ```

#### 1.6.2切换分支git checkout

* git checkout 分支名称
* 注意：git checkout的作用是检出，如果是文件的话，会放弃对文件的缓存区操作，但是要使用reset重置一下变更才行，如果是分支的话会切换过去

#### 1.6.3合并分支git merge

* git merge 分支名称

* 当我们新建分支并做完工作之后，想要把分支提交至master，只需要**切换到master仓库**，并执行**git merge 分支名**就可以了
* 注意：没有add和commit的文件在所有分支下都是可见的

#### 1.6.4查看所有分支git branch -a

* git branch -a

#### 1.6.5删除本地分支git branch -D

* git branch -D

#### 1.6.6删除远程分支git push origin --delete

* git push origin --delete

### 1.7GitHub

1.在本地创建一个ssh的key，因为github是使用ssh进行通讯的

```
ssh-keygen -t rsa -C "your_email@example.com"
```

-t 指定密钥类型，默认是 rsa ，可以省略。
-C 设置注释文字，比如邮箱。
-f 指定密钥文件存储文件名，一般我们默认，让存储到默认路径以及默认文件名

它会要求输入Enter file in which to save the key (/home/stephenzhou/.ssh/id_rsa)

这里是生成的sshkey文件名，我们可以回车使用默认文件名

除此之外还会让你输入

Created directory '/home/stephenzhou/.ssh'.
Enter passphrase (empty for no passphrase): 
这个密码会在让你push提交时候要输入的，除了git登录密码，还要输入这个密码，直接回车则空密码，这里我们直接回车

接着会让你在此输入密码，验证这里依旧回车

Enter same passphrase again：

生成之后你就会看到这样的界面:

<img src="E:\课程资料\springboot\黑马springboot\图片\ssh.png" style="zoom:150%;" />

生成的ssh文件如果不使用-f指定的话会生成在用户目录(C:\Users\xu\.ssh)下的.ssh目录中，.ssh是隐藏文件，可以使用ls -ah看到，使用cd ~进入用户主目录，然后cd进入到.ssh目录中可以看到文件

1、cd ~

2、cd .ssh

3、vim id_rsa.pub



## 2、SpringBoot3项目打包和运行

  ### 6.1 添加打包插件

    > 在Spring Boot项目中添加`spring-boot-maven-plugin`插件是为了支持将项目打包成可执行的可运行jar包。如果不添加`spring-boot-maven-plugin`插件配置，使用常规的`java -jar`命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。

```XML
<!--    SpringBoot应用打包插件-->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

  ### 6.2 执行打包

在idea点击package进行打包

可以在编译的target文件中查看jar包

  ### 6.3 命令启动和参数说明

    `java -jar`命令用于在Java环境中执行可执行的JAR文件。下面是关于`java -jar`命令的说明：

```XML
命令格式：java -jar  [选项] [参数] <jar文件名>
```

    1. `-D<name>=<value>`：设置系统属性，可以通过`System.getProperty()`方法在应用程序中获取该属性值。例如：`java -jar -Dserver.port=8080 myapp.jar`。
    2. `-X`：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：
        - `-Xmx<size>`：设置JVM的最大堆内存大小，例如 `-Xmx512m` 表示设置最大堆内存为512MB。
        - `-Xms<size>`：设置JVM的初始堆内存大小，例如 `-Xms256m` 表示设置初始堆内存为256MB。
    3. `-Dspring.profiles.active=<profile>`：指定Spring Boot的激活配置文件，可以通过`application-<profile>.properties`或`application-<profile>.yml`文件来加载相应的配置。例如：`java -jar -Dspring.profiles.active=dev myapp.jar`。
    
    启动和测试：
    
    ![](https://secure2.wostatic.cn/static/66fP6WRTExeyyKpybyBx7B/image.png?auth_key=1714129591-mBNL5qr36JQgSa46TQtta9-0-26f070ecba3de6d19ab00d71f5e9b521)
    
    注意： -D 参数必须要在jar之前！否者不生效！